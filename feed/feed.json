{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Modern Interoperable Messaging",
  "language": "en",
  "home_page_url": "https://messaging-interop.github.io/",
  "feed_url": "https://example.com/feed/feed.json",
  "description": "Ideas for portable, secure, private messaging",
  "author": {
    "name": "Mark Xue",
    "url": "https://messaging-interop.github.io/about/"
  },
  "items": [{
      "id": "https://messaging-interop.github.io/posts/7-Related-Work/",
      "url": "https://messaging-interop.github.io/posts/7-Related-Work/",
      "title": "7. Related Work",
      "content_html": "<p>This sketch draws on a wealth of prior work that has has gotten us where we are today. This architecture draws inspiration from (and uses as a security primitive) ratcheting message security keys from Double Ratchet and MLS.</p>\n<p>Message transmission architecture has inspiration from onion routing, and is adapted for the different nature of store and forward messaging from client-server sessions. Address diversification is structurally similar to onion routing, and I expect rate limiting between receiving and sending services will draw on operational experience from Tor nodes as well as email domain reputation heuristics.</p>\n<p>Indeed, a conceptual ancestor to onion routing is David Chaum’s proposal for anonymous communication using mixnets:\n<a href=\"https://dl.acm.org/doi/pdf/10.1145/358549.358563\">https://dl.acm.org/doi/pdf/10.1145/358549.358563</a></p>\n<p>I’ve also found helpful (if time-shifted) discussion from Trevor Perrin’s Modern Messaging mailing list archives and the many active participants there who have raised ideas and feedback relevant to different aspects of this sketch.\n<a href=\"https://moderncrypto.org/mail-archive/messaging/\">The Messaging Archives</a></p>\n",
      "date_published": "2022-07-07T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/6.3-Sending-Service/",
      "url": "https://messaging-interop.github.io/posts/6.3-Sending-Service/",
      "title": "6.3. Sending Service",
      "content_html": "<p>The main function of a sending service is as an agent of the user to receive encrypted messages from a user’s device and route them to a receiving service.</p>\n<p>To keep the system performant, the Proton protocol should have an established maximum size. Conformant with other secure messaging protocols, larger attachments can be transmitted out of band of the messaging protocol by uploading an encrypted blob to cloud storage and transmitting the symmetric key through the messaging protocol. The sending service is the most natural place to host this blob storage, as an agent of the sender. Sending services can also serve to abstract away a user’s many devices by providing a way to deduplicate responses from many devices (e.g. an ack message from all of a user’s devices).</p>\n<h2 id=\"basic-implementation\" tabindex=\"-1\">Basic Implementation <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#basic-implementation\" aria-hidden=\"true\">#</a></h2>\n<p>A basic service provider disassociates outgoing messages from user accounts by use of <a href=\"https://blog.cloudflare.com/eliminating-captchas-on-iphones-and-macs-using-new-standard/\">private access tokens</a> to rate limit an unauthenticated endpoint.</p>\n<p>The service provider exposes 2 API’s:</p>\n<ul>\n<li>A message send API, where users provide a private access token, a receiving service (by domain), a recipient address, and an encrypted cipher text.</li>\n<li>A blob upload API, which accepts (a different class of) private access token a file upload, and returns a url for the file.</li>\n</ul>\n<h2 id=\"supporting-services\" tabindex=\"-1\">Supporting Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#supporting-services\" aria-hidden=\"true\">#</a></h2>\n<p>A sending service is also a natural place to host supporting functionality.</p>\n<h3 id=\"message-de-duplication\" tabindex=\"-1\">Message De-duplication <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#message-de-duplication\" aria-hidden=\"true\">#</a></h3>\n<p>To help a user's devices appear as a single entity to remote parties, some messages should be coalesced into one. E.g. if relationship managers acknowledge receipt of messages, N ack's will reveal that the recipient has N online devices. For automated messages like these, relationship managers can attach a message de-dupe id (and agree between devices on a consistent method of generating it), so that the sending service implements a policy of only sending one message for a particular de-dupe id.</p>\n<h3 id=\"synchronizing-cross-user-state\" tabindex=\"-1\">Synchronizing Cross-user state <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#synchronizing-cross-user-state\" aria-hidden=\"true\">#</a></h3>\n<p>Decentralized state management across users is a complex problem. This comes from a number of applications, including group membership and state.<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#fn1\" id=\"fnref1\">[1]</a></sup> Sending services, as a agent of user's devices in hosting data for persistent availabilty by other parties, can also host canonical state of this kind. A sending service acting in this way would fulfill the message ordering function of a delivery service in the MLS architecture.</p>\n<p>Because there are no inherent links between a user's identity (or addresses) within a group, and their identity in other conversations, a sending server can safely hold delivery addresses and IPK's for group members, so that it can perform more complex functions of message fan-out, and sending end to end encrypted messages between the sending service and member protons.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>Signal explains the reasons they moved to a centralized, server-maintained group state, and their mitigations to preserve group privacy: <a href=\"https://signal.org/blog/signal-private-group-system/\">https://signal.org/blog/signal-private-group-system/</a> <a href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-07T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/6.2-Receiving-Service/",
      "url": "https://messaging-interop.github.io/posts/6.2-Receiving-Service/",
      "title": "6.2. Receiving Service",
      "content_html": "<p>draft</p>\n",
      "date_published": "2022-07-07T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/6.1-Relationship-Manager/",
      "url": "https://messaging-interop.github.io/posts/6.1-Relationship-Manager/",
      "title": "6.1 Relationship Manager",
      "content_html": "<p>Draft</p>\n",
      "date_published": "2022-07-07T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/5.4-Organizations/",
      "url": "https://messaging-interop.github.io/posts/5.4-Organizations/",
      "title": "5.4. Organizational Identity",
      "content_html": "<p>Protons solve a number of problems or businesses (or any organization) that communicate with individuals, for which a phone number is a poor abstraction for the many entities (and vendors) that comprise an organization.</p>\n<p>My bank has many phone numbers. There are many scammers who call me posing as my bank, or as a social security agency. People are also habituated to providing authenticating information over the phone, a rich target for phishing.</p>\n<p>Organizations today already have a way of establishing a cryptographic identity - through a CA for a domain. Which while imperfect, is a robust claim that a key belongs to Bank of America. And while I might look on the Bank of America website to check that a phone number is actually theirs, attestation and associated identities allow Bank of America to define some set of identities representing different functional teams - their fraud resolution, customer service.</p>\n<p>Businesses, like consumers, are also facing a fracturing of their messaging platforms as competing services offer B2C platforms, indexed on the same phone number. Should a business send an SMS, or a platform's variety of message, or blast the customer on all of them? A proton, as a representation of a single relationship, means that senders need to only worry about the priority and mode of the message - to include a push notification to their own app, not which client App the user is more likely to use.</p>\n<p>The assumption that sending frequency is capped at the rate of a human's activity is mostly relevant to the relationship between senders devices and their sending service. Organizations are not likely to have device-bound identities, and will likely use a vendor which integrates the relationship manager, and sending and receiving services in a hosted platform. From a receiving service's standpoint, this vendor's sending service that is responsible for all of an organization's B2C relationships, still looks like a well-behaved sending service as it will be sending well-addressed and correctly signed messages to distinct recipients.</p>\n<p>Some allowance might need to made for burst activity (push notification updates to sports scores, perhaps), but that can be resolved non-technically with arrangements between receiving and sending services of sufficient volume that such bursts are an issue.</p>\n",
      "date_published": "2022-07-06T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/5.3-Attachments/",
      "url": "https://messaging-interop.github.io/posts/5.3-Attachments/",
      "title": "5.3. Attachments",
      "content_html": "<p>The proton architecture is intended for store and forward messages that contain encoded text, keys, and URI's resulting from a human action. Data that does not fit, like images, should be sent in an attachment flow that only needs to be standardized between relationship managers.</p>\n<p>The RM message format must include a format for attachments that specifies:</p>\n<ul>\n<li>the encryption and integrity key(s)</li>\n<li>URI for the ciphertext\n<ul>\n<li>duration of validity of the URI</li>\n</ul>\n</li>\n</ul>\n<p>Messages that do not fit in a maximum proton message size (e.g. long emails, or many attachments), can be encoded and sent as an attachment.</p>\n<p>Users should generally rely on their receiving and sending services, as the last hop from the device, for hosting and retrieving blob content. Sketches of implementations:</p>\n<h3 id=\"sending-services\" tabindex=\"-1\">Sending Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/5.3-Attachments/#sending-services\" aria-hidden=\"true\">#</a></h3>\n<p>Sending services can provide users with a resource to upload arbitrary ciphertexts and host them for a fixed duration, under some quota policy.</p>\n<h3 id=\"receiving-services\" tabindex=\"-1\">Receiving Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/5.3-Attachments/#receiving-services\" aria-hidden=\"true\">#</a></h3>\n<p>Users should not generally directly fetch resources from arbitrary servers from their device(s). Receiving services can proxy or cache attachments on behalf of the recipient.</p>\n",
      "date_published": "2022-07-06T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/5.2-Self-introductions/",
      "url": "https://messaging-interop.github.io/posts/5.2-Self-introductions/",
      "title": "5.2. Self-Introduction",
      "content_html": "<p>There are circumstances where I want to talk to people I haven’t met yet, or have a means to introduce themselves. E.g. journalists that post a Signal number publicly, or people who publish an email address on their website (often with some obfuscation to defeat web scraping bots).</p>\n<p>Ideally, these self-introductions would be to a scoped identity, so I can identify the source of self-introduction, and have mitigations against abuse like rate limiting. What we want, then, is not to post a static address, but an online, interactive resource, that grants a rate-limited introduction.</p>\n<p>We can do this by delegating an introduction identity to this introduction service in the following way:\nA user generates\n- $$IPK_P$$ as a public identity,\n- a virtual address $$VA$$ marked for incoming self-introduced messages\n- optionally, some message security pre-keys\nAnd gives them to the introduction service. The introduction service generates a delegated introduction IPK and sends it to the user.</p>\n<p>The external agent can respond to rate-limited requests by\n- Signing a requester’s IPK with its delegated introduction IPK\n- Diversifying the virtual address derived from VA\nAnd returning those to the requester along with pre-keys (if available)</p>\n<p>The user can then accept messages on the VA if they come from an IPK signed by DI. The diversified addresses are single use - they shouldn’t accept messages from different IPK’s.</p>\n",
      "date_published": "2022-07-06T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/5.1-Backup/",
      "url": "https://messaging-interop.github.io/posts/5.1-Backup/",
      "title": "5.1. Backup",
      "content_html": "<p>People need to be able to continue their conversations if they lose their devices and the data on them. Today, this happens because identities (phone numbers and email addresses) are recoverable by appeal to the authority of the service provider, and often some form of contacts or implicit contacts (in message history) are escrowed with some service providers.</p>\n<p>So today, services can impersonate you (in practice, be convinced to allow someone to impersonate - for example in a SIM swap attack), and know who you talk to.</p>\n<p>Photon Relationships can be backed up in a variety of ways reflecting different tradeoffs of recovery and security. Most users, who have cryptographic identities stored securely on their devices, should never escrow their device-stored private keys - compromise of private keys would allow an attacker to impersonate the user.</p>\n<p>We have technologies shipping at scale today that preserve end to end security and allow users to recover their secrets from other devices in a sync circle, or from an escrowed store protected by a secret only the user knows. There are also shipping technologies where users can back up their private data using shared secrets so that no one party can recover the user's data.<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/5.1-Backup/#fn1\" id=\"fnref1\">[1]</a></sup> These methods would be safe to store private keys and allow me to recover from loss of a device without disturbing my relationships. I lose my phone, I recover my relationships from my desktop, and life continues.</p>\n<p>There are users who do not have devices, who today authenticate to online services with a user secret, and rely on the honest behavior of their service providers to not impersonate them. These users should also be able to participate in Photon relationships, but their relationship manager must be honest in representing that these user’s identities are escrowed and not device bound.</p>\n<p>We can provide a third recovery mechanism that is robust against losing all my data and forgetting my recovery secret(s), but has safeguards against the escrow party impersonating me - using the notion of introductions.</p>\n<h3 id=\"escrowed-relationship-backup\" tabindex=\"-1\">Escrowed Relationship Backup <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/5.1-Backup/#escrowed-relationship-backup\" aria-hidden=\"true\">#</a></h3>\n<p>Alex has a relationship with Blair that is based on cryptographic secrets stored in their respective protons. To protect against the loss of that data, Alex can introduce Blair to a future Alex $$A’$$, and escrow $$A'$$'s keys with a third party.</p>\n<p>The data Alex needs to escrow are:</p>\n<ul>\n<li>A long-term address for Blair.</li>\n<li>Blair’s IPK for this relationship</li>\n<li>A signing key for $$A’$$</li>\n<li>A preferred name for Blair</li>\n</ul>\n<p>If Alex loses all of their proton data, they can obtain this backup, notify all their relationships of the loss, and use each $$A'$$ to introduce the relationship to a new device resident identity $$A_r$$.</p>\n<p>As with introductions, remote parties should only accept the use of this placeholder key $$A'$$ for introduction to a new identity. The escrow party cannot impersonate the Alex, but can falsely claim to be a future, post-recovery Alex $$A_r$$. This should be easy to repudiate if Alex is still online. Recipients of such a recovery message should immediately consult $$A$$, and until they can verify $$A_r$$, consider the possibility that the escrow party had inserted themselves in the conversation.</p>\n<p>If Alex’s relationship with Blair is based on a publicly attested identity (i.e. a Twitter handle), Alex can instead rely on Twitter for identity recovery, and to publish a new IPK and address(es) for Alex.</p>\n<p>Escrow parties, then, learn about the remote parties that Alex communicates with. They may be able to associate those backed up contacts with outgoing messages to the long-term address, but by design there is nothing to associate those contacts with user’s incoming messages. Receiving services are natural candidates to escrow these contacts. Using two separate receiving services as the system intends, prevents the escrow party from also denying receiving service to prevent repudiation of a misused backup.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>Apple's account recovery contact: <a href=\"https://support.apple.com/guide/security/account-recovery-contact-security-secafa525057/1/web/1\">https://support.apple.com/guide/security/account-recovery-contact-security-secafa525057/1/web/1</a> <a href=\"https://messaging-interop.github.io/posts/5.1-Backup/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-06T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/4.4-Transit-Privacy/",
      "url": "https://messaging-interop.github.io/posts/4.4-Transit-Privacy/",
      "title": "4.4. Message Privacy in Transit",
      "content_html": "<p>Today, messages - even those that are end to end encrypted - are transmitted with sender and recipient identities in the clear. Eavesdroppers, even if they can’t read the contents, can still determine who is talking to whom, at what time.</p>\n<p>The identities serve the following purposes:</p>\n<ul>\n<li>Parties that route messages need to know their destination</li>\n<li>Recipients need to know the originator of a message\n<ul>\n<li>Encryption schemes depend on the originator identity as the index for which keys to decrypt and authenticate an incoming message</li>\n</ul>\n</li>\n<li>Spammers can have actions enforced against their sending identity at each step in the transmission chain.</li>\n</ul>\n<p>The proton architecture improves on this in two key ways:</p>\n<ul>\n<li>Senders do not attach their identity to the message\n<ul>\n<li>The return path, e.g to acknowledge receipt of a message, is independent of the path the message was received on.</li>\n</ul>\n</li>\n<li>In place of the sender-receiver identity pair, adresses now convey the necessary metadata\n<ul>\n<li>for the receiving service to deliver the message to the intended recipient</li>\n<li>for the recipient to resolve which relationship a message is intended for</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"virtual-addresses\" tabindex=\"-1\">Virtual Addresses <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.4-Transit-Privacy/#virtual-addresses\" aria-hidden=\"true\">#</a></h3>\n<p>Receiving services should provide their users with a supply of virtual addresses, and a mechanism for any sender to further diversify an address so that it is resolvable by the receiving service and no one else.</p>\n<p>Users should assign virtual addresses to relationships and share them with their correspondents; they should not be reused across relationships as that may inadvertently link relationships. Because virtual addresses should not be shared between conversations, the RS can observe that messages for the same virtual address are part of the same conversation. To further protect metadata about a user’s conversations, users should use multiple virtual addresses in the same conversation - ideally, a distinct address per message.</p>\n<h3 id=\"address-diversification\" tabindex=\"-1\">Address diversification <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.4-Transit-Privacy/#address-diversification\" aria-hidden=\"true\">#</a></h3>\n<p>This implies that senders and recipients should be able to diversify addresses for a user, producing new addresses that are unlinkable except by the receiving service. We can do so with the following scheme:</p>\n<p>We define address diversification on a space of addresses $$A = {0,1}^n$$ as a triple of probabilistic polynomial-time algorithms $$(Gen, Diversify, Resolve)$$ such that</p>\n<ol>\n<li>The key generation Gen takes as input the security parameter $$1^n$$ and outputs a pair of keys (pk, sk).</li>\n<li>The probabilistic diversification algorithm Diversify takes as input a public key pk and an address $$a$$ from A, and outputs a diversified address $$d$$.</li>\n<li>The deterministic Resolve algorithm takes as input a private key $$sk$$, and a diversified address $$d$$, and outputs an address $$a$$ or a symbol denoting failure.</li>\n</ol>\n<p>Resolve(Diversify($$a$$, $$pk$$), $$sk$$)  should return $$a$$, and it should not be possible for an adversary to determine $$a$$ given Diversify($$a$$) without $$sk$$.</p>\n<p>Diversify should produce indistinguishable outputs, that is, an attacker cannot determine if the output of Diversify was from the same input address, unless they possess the secret key $$sk$$.</p>\n<p>A public key encryption scheme should satisfy these requirements.</p>\n<p>We apply address diversification as follows:</p>\n<h3 id=\"virtual-address-generation\" tabindex=\"-1\">Virtual address generation <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.4-Transit-Privacy/#virtual-address-generation\" aria-hidden=\"true\">#</a></h3>\n<p>The goals of this scheme:</p>\n<ul>\n<li>A receiving service can resolve addresses to a user</li>\n<li>Parties other than the receiving service and the user cannot link addresses to the same user</li>\n<li>Parties other than the user cannot link addresses to the same relationship</li>\n</ul>\n<ol>\n<li>\n<p>A user and their receiving service agree on a root address $$r$$ ( e.g. a UUID), from which we derive additional addresses. This address cannot be invalidated until all derived addresses have expired, so RM clients should periodically generate a new root address so that old ones can be expired.</p>\n</li>\n<li>\n<p>The Receiving Service generates a diversification keypair ($$pk$$, $$sk$$), and publishes the public diversification key. These keys should also be periodically rotated, and identified by a key generation. So in practice, ($$pk_i$$, $$sk_i$$).</p>\n</li>\n<li>\n<p>The user diversifies the root addresses into recipient-diversified addresses $$RDA_j$$ by applying the diversification function with the RS’s public diversification key:</p>\n<p>$$RDA_j = j || Diversify(r, pk_j)$$</p>\n</li>\n</ol>\n<p>The user should assign distinct RDA’s to each of their relationships, so that presented with a ciphertext addressed to an RDA, the user knows which relationship’s keys it should apply to the ciphertext.</p>\n<p>So far, anyone can generate an RDA that resolves to any root address $$p$$, since $$pk$$ is publicly published. We relay on senders using this to diversify addresses to prevent linking by sending services, and we should not rely on the secrecy of a value shared among many users, like the set of all customers of a receiving service.</p>\n<p>We can ensure that only a user can generate addresses for themselves, by requiring that RDA’s be signed by the user using a signing key $$S_k$$ generated for this purpose and registered with the RS:</p>\n<pre><code>$$RDAS_j = j || Sign( j || SRDA_j, S_k )$$\n</code></pre>\n<p>where i is the generation of the Receiving service’s public key.</p>\n<p>The user then sends addresses of the form $$RDAS_j$$  to remote parties</p>\n<p>These remote parties themselves can diversify the RDA_j by applying the RS’s published diversification key:</p>\n<pre><code>$$SDA_j = k ||Diversify(RDAS_j, pk_k)$$\n</code></pre>\n<p>So, a Relationship Manager, when sending a message, should provide the following to it’s sending service (independent of any authentication or private access token required to use the sending service):</p>\n<ul>\n<li>The ciphertext to be decoded by the remote relationship manager</li>\n<li>The receiving service</li>\n<li>A recipient address of the form $$SDA_j$$</li>\n</ul>\n<p>The sending service’s responsibility is to look up the receiving service’s configuration (by analog to email, examine the MX record for the recipient domain), and transmit the ciphertext and recipient address.</p>\n<p>The receiving service, on receipt of a ciphertext $$c$$ for diversified address $$j || da$$:</p>\n<ul>\n<li>Resolves the sender-diversified address to a recipient-diversified address\n<ul>\n<li>$$(j || rda || signature) = Resolve(da, sk_k)$$</li>\n</ul>\n</li>\n<li>Resolves the recipient-diversified address to a root address\n<ul>\n<li>$$r = Resolve(rda, sk_j)$$</li>\n</ul>\n</li>\n<li>Checks if a user corresponds to that root address, and users the signature key(s) for that user to verify the signature on the recipient-diversified address.</li>\n</ul>\n<p>If both resolution steps, and the signature step succeeds, the receiving service can deliver the message to the user corresponding to the root address.</p>\n",
      "date_published": "2022-07-05T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/4.3-Unsolicited-Messages/",
      "url": "https://messaging-interop.github.io/posts/4.3-Unsolicited-Messages/",
      "title": "4.3. Unsolicited Messages",
      "content_html": "<p>The threat model of unsolicited mail changes considerably if only some <a href=\"https://messaging-interop.github.io/posts/5.2-Self-introductions\">defined endpoints</a> are open to arbitrary senders. Rate limiting can be applied at the point of establishing those self-introductions, not at the point of message receipt.</p>\n<p>Outside of those self-introductions, messages in the proton architecture are dropped unless they have a correctly formed address (including a recipient signature on an intermeidate form of the address), and a correct sender signature for the expected sender for that address.</p>\n<p>Today, spammers have an easy task of obtaining or guessing static, low entropy recipient addresses, and their primary challenge is convincing recipient systems to accept bulk messages. They can often do so by aggregating false individual users (phone number and email accounts), that are difficult to distinguish from normal users until they have successfully sent enough unsolicited mail to be flagged by volume, content, or other behavior as a bulk mailer.</p>\n<p>Under the proton architecture, addresses are high-entropy and easily updated. If an attacker is successful in obtaining or guessing an address, they still have to forge a sender signature, at which point they can only pose as the expected sender, not as an arbitrary new identity.</p>\n<p>The key difference is that where as today, spammers are successful until flagged, authentication prevents spammers from successfully sending unsolicited messages, and attempts to learn information by enumerating the address space or using recipients as encryption oracles exhibit behavior that can be identified and blocked.</p>\n<p>Consequently, receiving services, in accepting a message from sending services, should only confirm the correct acceptance of bytes (and any transport layer message integrity), not the validity of any particular address. Failure to resolve the address, in volume, should be considered a reputational hit for that particular sending service.</p>\n<h3 id=\"device-compromise\" tabindex=\"-1\">Device compromise <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.3-Unsolicited-Messages/#device-compromise\" aria-hidden=\"true\">#</a></h3>\n<p>This does raise the incentive to compromise devices to obtain sender signing keys. The attacker's ability is more powerful in that they can impersonate that particular sender, but limits their ability to pose as an alternate identity.</p>\n",
      "date_published": "2022-07-05T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/4.2-Trust/",
      "url": "https://messaging-interop.github.io/posts/4.2-Trust/",
      "title": "4.2. Trust",
      "content_html": "<p>The privacy of my messages - in transit and after receipt - relies on trust in many different parties, including the other party to a relationship.</p>\n<p>The proton architecture guarantees that people are exchanging messages with (and only with) who they expect to be talking to, and that they are transmitted with ephemeral addresses. It makes no promises about what happens after the message is received, how many devices the recipient is running, or even if the recipient is running a hosted service where a server stores their signing keys. We should not exclude people from this architecture who - for a variety of reasons - do not use device-bound identities. They may not have a device, or have sufficient trust in their device security or recovery methods.</p>\n<p>A very useful property of some messaging apps is ephemerality - that messages disappear after some time, and the client app makes it difficult for the user to exfiltrate them - e.g. by screenshotting. For users to have an assurance of ephemerality, they need stronger assurances about the remote party's software.</p>\n<p>This is a known problem with shipping solutions that raise the difficulty of misrepresenting the software that I'm running. Video game clients regularly attest their client software behavior to a server to reduce cheating. iOS has a shipping feature where the OS assists with this attestation<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/4.2-Trust/#fn1\" id=\"fnref1\">[1]</a></sup>.</p>\n<p>To get a guarantee of ephemeral messages, I should layer the systems. I trust the relationship manager transmit, securely and privately, messages in a relationship. The other party and I can agree on an app, that implements its own secret sharing atop the relationship channel.</p>\n<p>This implies that when client apps exchange messages through a relationship manager, that the remote party's IPK be shared with the app.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://developer.apple.com/documentation/devicecheck/establishing_your_app_s_integrity\">Apple Developer Documentation</a> <a href=\"https://developer.apple.com/documentation/devicecheck/establishing_your_app_s_integrity\">https://developer.apple.com/documentation/devicecheck/establishing_your_app_s_integrity</a> <a href=\"https://messaging-interop.github.io/posts/4.2-Trust/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-05T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/4.1-Interoperability/",
      "url": "https://messaging-interop.github.io/posts/4.1-Interoperability/",
      "title": "4.1. Interoperability",
      "content_html": "<p>A key principle of this architecture is that users do not have to agree on a choice of software or services to communicate securely and privately. There are many ideas for hiding message metadata, but implementing novel strategies is difficult if one has to rely on both parties cooperating.</p>\n<p>This architecture is logically separated so that each piece of the architecture can implement novel approaches. These points of separation require interoperability in the following ways</p>\n<h3 id=\"relationship-manager-to-relationship-manager\" tabindex=\"-1\">Relationship Manager to Relationship Manager <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#relationship-manager-to-relationship-manager\" aria-hidden=\"true\">#</a></h3>\n<ul>\n<li>Relationship Managers must agree on a cipher text and plaintext message format and cipher suites for encrypting and decrypting cipher texts.</li>\n<li>They must interoperate on mechanisms for exchanging and verifying public keys directly</li>\n<li>They must interoperate on commands for message exchange and proton state:\n<ul>\n<li>Message received</li>\n<li>Message read (if recipients choose to send it)</li>\n<li>Updates to associated data for the proton:\n<ul>\n<li>e.g. preferred name, receiving services, addresses</li>\n<li>including requests to update addresses about to expire</li>\n</ul>\n</li>\n<li>Group operations</li>\n<li>Introduction to backups</li>\n<li>Merge requests</li>\n<li>Relationship terminated\n<ul>\n<li>(Clients can also silently ignore relationships, or stop sending message receipt ack's, but users may wish to explicitly message this)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"sending-service-to-receiving-service\" tabindex=\"-1\">Sending Service to Receiving Service <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#sending-service-to-receiving-service\" aria-hidden=\"true\">#</a></h3>\n<p>Receiving Services must be able to accept messages up to the agreed upon protocol size for an arbitrary address from Sending Service.</p>\n<h3 id=\"sending-and-receiving-services\" tabindex=\"-1\">Sending and Receiving Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#sending-and-receiving-services\" aria-hidden=\"true\">#</a></h3>\n<p>Sending and receiving services may expose just server API for RM clients. However, services may find it helpful to use client code to execute novel strategies to hide message metadata from themselves, for example with the use of private access tokens.</p>\n<p>We can enable users to use a single relationship manager with different (possibly concurrently) sending and receiving services and simplify the interface as follows:</p>\n<h3 id=\"sending-services\" tabindex=\"-1\">Sending Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#sending-services\" aria-hidden=\"true\">#</a></h3>\n<ul>\n<li>Sending services should provide the Relationship Manager with an API for the RM to send a message for a particular address</li>\n<li>Sending services should also provide the Relationship Manager with an API to upload a ciphertext to cloud storage, and return a URI where it can be retrieved.\n<ul>\n<li>Sending Services should provide the Relationship Manager with an API to learn about the availability (e.g. if offline) and capacity for message sending and attachment upload</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"receiving-services\" tabindex=\"-1\">Receiving Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#receiving-services\" aria-hidden=\"true\">#</a></h3>\n<p>Receiving services have two key functions - address generation, and message receipt.\nThe receiving service should expose API to Relationship Managers for address management:</p>\n<ul>\n<li>generate a long-term address\n<ul>\n<li>optionally, revoke a long-term address</li>\n</ul>\n</li>\n<li>generate an ephemeral, derived address from a long-term address</li>\n</ul>\n<p>Receiving services should offer a mechanism for any party to, given an address A' for that service, derive an ephemeral address that is only linkable to A by the receiving service. Section <a href=\"https://messaging-interop.github.io/posts/4.4-Transit-Privacy\">4.4 Transit Privacy</a> gives a sketch of how to do so with public key cryptography.</p>\n<p>The receiving service should also expose API to Relationship Managers for message delivery:</p>\n<ul>\n<li>\n<p>deliver a message to the Relationship Manager for a given address</p>\n</li>\n<li>\n<p>Allow the Relationship Manager to specify latency for specific long-term addresses (e.g. to manage the pull/push tradeoff centrally within the relationship manager)</p>\n</li>\n<li>\n<p>The RM provides an API for the SS to tell it of changes to the sending configuration (specifically, permitted payload sizes), and available sending options (e.g. a privacy vs latency trade off)</p>\n</li>\n</ul>\n<h2 id=\"portability\" tabindex=\"-1\">Portability <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#portability\" aria-hidden=\"true\">#</a></h2>\n<p>These interfaces allow for easy portability</p>\n<h3 id=\"sending-service\" tabindex=\"-1\">Sending Service <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#sending-service\" aria-hidden=\"true\">#</a></h3>\n<p>Relationship managers may switch arbitrarily among sending services without any cooperation from remote parties. People should maintain at least 2 for redundancy, and relationship managers may freely use any service that the user has configured.</p>\n<h3 id=\"receiving-service\" tabindex=\"-1\">Receiving Service <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#receiving-service\" aria-hidden=\"true\">#</a></h3>\n<p>Because addresses have a finite lifetime, and relationship managers can safely and automatically update them without user intervention, people can safely cutover from one receiving service to another without losing messages. They should already have redundant receiving services configured.</p>\n<p>After a user tells their relationship manger to sunset a particular receiving service R</p>\n<ul>\n<li>The relationship manager should cease issuing addresses from R and cut over to alternate receiving services.\n<ul>\n<li>The user can safely terminate their relationship with R after the last issued address has expired</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"relationship-manager\" tabindex=\"-1\">Relationship Manager <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#relationship-manager\" aria-hidden=\"true\">#</a></h3>\n<p>Switching relationship managers is more complex. Relationship managers should allow users to export their messages (it's their data), but to preserve the security of a user's communications, relationship managers should not allow the export of private keys. When people choose to switch relationship managers (e.g. from a cross-platform app to the platform's native implementation of a relationship manager, or vice versa), this necessarily has to be an event visible to remote parties as an introduction.</p>\n<p><a href=\"https://messaging-interop.github.io/posts/5.1-Backup.md\">Backed-up relationships and future identities</a> form a useful data structure that can be safely handed off to a successor app, that takes over identities from the previous app.</p>\n",
      "date_published": "2022-07-05T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/4-Ideas/",
      "url": "https://messaging-interop.github.io/posts/4-Ideas/",
      "title": "4. Ideas",
      "content_html": "<p>We've now described enough of the architecture and mechanics to discuss the core goals and ideas.</p>\n<h2 id=\"goals\" tabindex=\"-1\">Goals <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#goals\" aria-hidden=\"true\">#</a></h2>\n<p>The core goal of this architecture is to support the store and forward delivery of discrete messages, end to end encrypted between people as represented by cryptographic identities.</p>\n<p>These messages should have a size limit sufficient to allow for structured objects conveying Unicode encoded text, cryptographic keys, and URI's, but should not be a mechanism to transmit arbitrary packetized data. Each message should correspond to a human action (modulo automated state handling -e.g. an ack- of equal but no greater magnitude) - this forms a natural rate limit.</p>\n<p>The idea is rooted in messaging, but extends to other data that people can exchange like emails, sharing invitations, call invitations, or moves in a turn-based game. It is not a real-time streaming format for audio, video, or movements in a real-time game, which should utilize a streaming transport. However, it can be used to exchange data needed to bootstrap a streaming session between members of a proton relationship.</p>\n<p>There is no guarantee of ordering, nor should clients attempt to fit large payloads in multiple messages - messages that exceed the base size (pictures, long emails, documents) should be handled as <a href=\"https://messaging-interop.github.io/posts/5.3-Attachments\">attachments</a> as they commonly are today.</p>\n<p>Organizations with one to many relationships can fit into this framework, discussed further in <a href=\"https://messaging-interop.github.io/posts/5.3-Organizations\">Organizational Identity</a></p>\n<h2 id=\"deconstructed-messaging\" tabindex=\"-1\">Deconstructed Messaging <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#deconstructed-messaging\" aria-hidden=\"true\">#</a></h2>\n<p>For simplicity, a messaging service combines several different pieces of functionality:</p>\n<ul>\n<li>Authentication - each service manages its own set of identities, tied to an external identity (phone number)</li>\n<li>Message transport</li>\n<li>Client application that stores the user's messages after receipt, and implements a variety of message payloads - standard (images, links) and custom (payments)</li>\n</ul>\n<p>Traditionally, identity has also been bound up with transport. To issue phone numbers, you must be a carrier. The issuer of an email identity are the parties that route the email. This both places a high bar on issuing identities, and binds identity to the service. There's been mixed success in the ecosystem of mail client applications - recent entrants have depended on the integration of client app and the email service.</p>\n<p>For conversations to be portable, they should handle identity independently from transport. For conversations to be interoperable, users need to be able to make independent choices about service providers and client applications.</p>\n<p>So instead of an architecture where members of different ecosystems can message each other, in the way that SMS gateways glued SMS to other messaging systems,<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/4-Ideas/#fn1\" id=\"fnref1\">[1]</a></sup> let's deconstruct the functionality. For Alex and Bob to communicate, they need each of the following pieces:</p>\n<h3 id=\"authentication\" tabindex=\"-1\">Authentication <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#authentication\" aria-hidden=\"true\">#</a></h3>\n<p>Alex and Blair need to exchange identities. We <a href=\"https://messaging-interop.github.io/posts(3.1-Identity)\">previously</a> outlined the ways that people can exchange cryptographic identities like they do phone numbers.</p>\n<h3 id=\"transport\" tabindex=\"-1\">Transport <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#transport\" aria-hidden=\"true\">#</a></h3>\n<p>Alex, from a device, wants to send a message to Blair using that identity. Individual devices are imperfectly online - we want to offload the store and forward to online services that act as online agents for our devices.</p>\n<p>Alex's device, then, should engage a persistently online sending service to offload outgoing messages from their device. That sending service can then attempt &amp; retry delivery to the remote party's online agent for receiving messages.</p>\n<p>These agents have asymmetric roles. Sending services are relatively simple - their role is to take a message from a device and faithfully deliver it to another server endpoint. The <a href=\"https://messaging-interop.github.io/posts/4-Ideas/posts/6.3-Sending-Service\">reference implementation</a> discusses how sending services can authenticate users without authenticating each message. They have related functionality</p>\n<p>Receiving services have a more complex role, since they need to distinguish among incoming messages, which users to route those messages to. Their responsibiity is to keep that knowledge private, by suppring a <a href=\"https://messaging-interop.github.io/posts/4-Ideas/(/posts/4.4-Transit-Privacy)\">virtual address scheme</a> that allows senders to use different addresses for each message.\nThey may engage in strategies to reduce their knowledge about this mapping - a maximalist strategy would be to deliver every message to every user.</p>\n<h2 id=\"reconstructing\" tabindex=\"-1\">Reconstructing <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#reconstructing\" aria-hidden=\"true\">#</a></h2>\n<p>This is a flexible system that allows users to make complex choices - but it is essential to have progressive complexity that doesn't require everyone to make these choices to use the system.</p>\n<p>People's primary or initial interaction with this architecture will be through the relationship manager app, as the way that they start relationships and communicate within them. It serves a set of functions that combine what people typically do within their messaging, contacts, and password manager apps. For simplicity, these apps should come with default receiving, sending, and identity attestation services out of the box, just as messaging apps do today with their backing service.</p>\n<h3 id=\"services\" tabindex=\"-1\">Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#services\" aria-hidden=\"true\">#</a></h3>\n<p>Sending and receiving services should be cheap to run - they are scaled for human-initiated text and code payloads. Both Apple and Google provide a free receiving service for their mobile OS's in the form of push notification services<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/4-Ideas/#fn2\" id=\"fnref2\">[2]</a></sup> - which end to end encrypted messaging systems today already run on top of for the last leg of delivery to mobile devices. A free tier might include an attachment service sufficient to allow users to send text attachments and images as existing services provide today. Just as with cloud hosting, a variety of economic models might support higher tiers of utilization.</p>\n<p>Key to this assumption is the distinction that sending and receiving services are responsible for message transport (and optionally hosting attachments), not the storage of the resulting plaintext.</p>\n<p>Because the relationship manager is responsible for the security of a person's private keys for their cryptographic identities, and for the backup and recovery of the corresponding relationships, it should also be the default agent for cloud storage and backup of a user's decrypted messages.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>SMS Gateway <a href=\"https://en.wikipedia.org/wiki/SMS_gateway\">https://en.wikipedia.org/wiki/SMS_gateway</a> <a href=\"https://messaging-interop.github.io/posts/4-Ideas/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>APNS (iOS) and Android both have a payload limit of 4KB: <a href=\"https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html\">https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html</a>  <a href=\"https://firebase.google.com/docs/cloud-messaging/concept-options\">https://firebase.google.com/docs/cloud-messaging/concept-options</a>\nAPNS provides a rudimentary form of virtual addressing, in which different developers get different addresses for the same device, to prevent tracking of user activity across apps. <a href=\"https://messaging-interop.github.io/posts/4-Ideas/#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-05T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/3.4-Devices/",
      "url": "https://messaging-interop.github.io/posts/3.4-Devices/",
      "title": "3.4. Multiple Devices",
      "content_html": "<p>We’ve so far described relationships and conversations between Protons - elements which represent a contextual identity in a relationship or group.</p>\n<p>In practice, people use multiple devices, and want to communicate from those devices as a unified identity. What devices I want to use with an identity is an implementation detail that I should not have to share with everyone I talk to.</p>\n<p>MLS proposes<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/3.4-Devices/#fn1\" id=\"fnref1\">[1]</a></sup>, and Signal and iMessage implement an architecture where devices are logically distinct members of a conversation or group, and the application layer abstracts (hides) that implementation by mapping devices to users by phone number. One could imagine that a proton could cryptographically attest to some set of devices with device-specific identity public keys.</p>\n<p>But within a federated system, I cannot rely on the remote party’s software hiding how many devices I have, as iMessage and Signal do. Protons represent an identity, and the devices I use are not part of that identity.</p>\n<p>Exposing to all of my relationships what devices I’m using, when that set changes, which device any particular message comes from, and if any particular device is late in sending automated replies like message ack’s, reveals private information that should be hidden from remote parties.</p>\n<p>A Proton represents an identity, not a device, and it is the responsibility of the relationship manager client to implement its own strategy for presenting multiple devices as a single cryptographic identity. Here are some possible strategies:</p>\n<ol>\n<li>Client fan-out\n<ul>\n<li>The proton cryptographic state is maintained on one device, which fans out decrypted messages to other devices through an end to end messaging channel between devices. This requires the fan-out device to be online to receive messages.</li>\n</ul>\n</li>\n<li>Fan-out to receive, designate a leader to send\n<ul>\n<li>Devices may share cryptographic state using end to end encrypted messaging and/or cloud storage.\n<ul>\n<li>Devices, when sending a message in a relationship, should also send them to all peer devices to ensure the peer devices advance their ratchet state in concert with the sending device.</li>\n</ul>\n</li>\n<li>Devices may receive messages in parallel with no issue, but should avoid synchronously sending messages, as this would result in reuse of message keys and possibly sending conflicting DH ratchet keys.</li>\n<li>Devices could agree on a leader that is responsible for sending, and may use a server to reach consensus or designate a particular device to lead. This guarantees there are no conflicts from devices synchronously sending messages from the same ratchet state.</li>\n<li>This improves on the reliability of client fan-out as devices do not depend on each other to receive messages, and can take over the sending role from offline devices.</li>\n</ul>\n</li>\n<li>Leaderless send and receive\n<ul>\n<li>As in (2), devices could share cryptographic state using end to end encrypted messaging and/or storage, and receive messages in parallel.</li>\n<li>Unlike above, devices do not deconflict their outgoing messages, but they can use heuristics to avoid unnecessarily doing so.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"leaderless-multi-device-double-ratchet\" tabindex=\"-1\">Leaderless multi-device double ratchet <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/3.4-Devices/#leaderless-multi-device-double-ratchet\" aria-hidden=\"true\">#</a></h3>\n<p>What happens if multiple devices that share cryptographic ratchet state, simultaneously send different messages from the same ratchet state? Let’s call this a synchronous send conflict. Reuse of a message key is simpler, does not affect the encryption of future messages, and clients can decide to accept or reject each message. Synchronously sending a DH ratchet, however, will cause the DH ratchet to fork, depending on which message’s DH keys are applied to the ratchet.</p>\n<p>To a recipient with a single device that has implemented double ratchet, receiving a synchronous send conflict appears to be a buggy client - perhaps one that has a multithreading bug. The recipient would accept the first message and reject the second when it later arrives.</p>\n<p>From the sender’s standpoint, the devices should learn about the conflict from the peer messages that the sending devices sent alongside the outgoing messages. The devices don’t have to perform the complex task of reaching consensus on which fork of the DH ratchet chain to advance on - the remote party’s ack of the first message they receive ( and the only one of the two they accept) will decide which DH ratchet fork everyone should use.</p>\n<p>Relationship Managers that support multiple clients need to implement a heuristic to converge on a single DH ratchet, independent of any strategy the remote party pursues:</p>\n<ul>\n<li>In a multiple device to multiple device scenario, we can’t rely on the remote party resolving the fork. If conflicting messages M1 and M2 are sent, we must account for the possibility that different remote devices will acknowledge M1 and M2.</li>\n<li>The relationship manager on each client should accept any DH ratchet step that is acknowledged by the remote party as valid. This may result in multiple valid ratchet steps, forking the DH chain, but devices should agree on the set of valid chains. When a device sends a (non-automated) message, it should apply a longest chain + lexicographic ordering of the valid chains, where the lexicographic ordering need only be consistent among devices of the same user.</li>\n<li>I have an intuition that this results in convergence on a single chain, so long as a user's devices (but not both users) agree on a lexicographic ordering.</li>\n</ul>\n<p>This scenario requires further analysis.</p>\n<h3 id=\"revocation\" tabindex=\"-1\">Revocation <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/3.4-Devices/#revocation\" aria-hidden=\"true\">#</a></h3>\n<p>Post compromise security should allow for recovery if a device is compromised and removed from the circle of trust. The users’s own devices should no longer copy the removed device on their own messages, and a DH ratchet should prevent the compromised device from decrypting future messages.</p>\n<p>If a user believes that the device's keys may be compromised (e.g. if removing a device is initiated from another device), it may be helpful to roll the IPK and designate a new IPK to follow the one that preceded the removal of a possibly compromised device.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://messaginglayersecurity.rocks/mls-architecture/draft-ietf-mls-architecture.html#name-support-for-multiple-device\">The Messaging Layer Security (MLS) Architecture - 5.6. Support for Multiple Devices</a><a href=\"https://messaginglayersecurity.rocks/mls-architecture/draft-ietf-mls-architecture.html#name-support-for-multiple-device\">https://messaginglayersecurity.rocks/mls-architecture/draft-ietf-mls-architecture.html#name-support-for-multiple-device</a> <a href=\"https://messaging-interop.github.io/posts/3.4-Devices/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-04T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/3.3-Groups/",
      "url": "https://messaging-interop.github.io/posts/3.3-Groups/",
      "title": "3.3. Groups and Introductions",
      "content_html": "<p>How do I talk to multiple people? Introductions and group conversations are closely related ideas.</p>\n<p>Protons use MLS to ensure the security of group conversations.</p>\n<p>Each MLS client needs to be represented by an identity public key. Following the model of protons that represent an end of a 1:1 relationship, a group $$G$$ has members (clients) represented by a group proton $$GP_i$$ with the structure for a given $$G_c$$</p>\n<ul>\n<li>For each other group member $$GP_i$$:\n<ul>\n<li>A human-readable identity:\n<ul>\n<li>A string representing a preferred name</li>\n</ul>\n<ul>\n<li>(Optional) pronouns</li>\n<li>(Optional) A profile picture - could be emoji, monogram, or photo</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>An Identity Public Key ($$IPK_i$$)\n<ul>\n<li>Optionally, an external resource that attests to a link between $$IPK_i$$ and some external identity (e.g. a scoped username - B on Twitter)</li>\n</ul>\n</li>\n<li>A list of transport mechanisms (minimum 2), that each contains</li>\n<li>A well-known url representing the service identity and configuration:\n<ul>\n<li>E.g. <a href=\"http://signal.org/.well-known/Proton.json\">signal.org/.well-known/Proton.json</a></li>\n</ul>\n</li>\n<li>A long-term delivery address (this facilitates recovery)\n<ul>\n<li>With a guaranteed valid until date</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>An ephemeral delivery address for $$P_b$$\n<ul>\n<li>With a (nearer) guaranteed valid until date</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>An Identity private key for $$IPK_c$$ corresponding to the $$IPK_i$$ held by other group members\n<ul>\n<li>A set of associations of $$IPK_c$$ with other related protons (relationships)defined by cryptographic attestation - see [Identity].</li>\n</ul>\n</li>\n<li>An Identity private key for $$GP_c$$ corresponding to the $$IPK_c$$ held by other members of the group</li>\n<li>Message Security state variables\n<ul>\n<li>This is the MLS cryptographic state. <sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/3.3-Groups/#fn1\" id=\"fnref1\">[1]</a></sup></li>\n</ul>\n</li>\n</ul>\n<p>In MLS terminology:</p>\n<ul>\n<li>A Group Proton is a client of a group.</li>\n<li>Each relationship manager’s understanding of how it got the proton’s identity key is the authentication service</li>\n<li>The delivery service is decentralized - each client is responsible for distributing messages, and publishing keys and pre-keys for new joiners\n<ul>\n<li>Proton groups may enlist the use of an Attestation Service to publish self-add pre-keys.</li>\n<li>Proton groups may enlist the use of a server as the delivery service, to fan out messages and enforce a canonical ordering of epochs. The section on <a href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service\">sending services</a> describes this.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"introductions\" tabindex=\"-1\">Introductions <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/3.3-Groups/#introductions\" aria-hidden=\"true\">#</a></h3>\n<p>The act of adding participants to a group can be thought of an introduction, brokered by the person performing the add, between the new participants and the existing participants. To better understand the mechanics, let’s look at the example of Alex, who has relationships with Blair and Charlie, and wants to introduce them.</p>\n<p>Alex has two relationships AB and CB. Note that Alex has two independent cryptographic identities - Alex as Blair knows them ($$P_{AtoB}$$), and Alex as Charlie knows them($$P_{AtoC}$$)</p>\n<p><img src=\"https://messaging-interop.github.io/img/330.png\" alt=\"Diagram of the start condition, where Alex has two independent relationships\" /></p>\n<p>Figure 3.3.0</p>\n<p>Alex can introduce Blair and Charlie by starting a group thread between the three of them:</p>\n<p>(For shorthand, we will refer to a Proton interchangeably with its IPK. Most of these actions will be automatd by Alex's software.)</p>\n<ul>\n<li>\n<p>Alex generates a new IPK for their identity in this group, $$GP_A$$</p>\n<ul>\n<li>Alex sends $$GP_A$$  in AB and CB, and attests to a parallel relationship between $$GP_A$$ and the cryptographic identities Blair and Charlie already know for Alex - $$P_{A to B}$$ and $$P_{A to C}$$, respectively.</li>\n</ul>\n</li>\n<li>\n<p>Alex also generates placeholder identities for Blair ($$GP_{AB}$$) and Charlie ($$GP_{AC}$$), and sends the respective public and private keys to Blair and Charlie.</p>\n<ul>\n<li>That is, Alex sends in $$AB$$ the public key for $$GP_{AC}$$ and the private key for $$GP_{AB}$$, and symmetrically for $$AC$$.</li>\n<li>This step is required because we do not want to reuse cryptographic identities in different conversations, and allows Alex to asynchronously start a group without relying on Blair and Charlie to generate a new key pair. In any case, Blair and Charlie should not assume that Alex does not hold on to the private keys to the placeholder identities.</li>\n</ul>\n</li>\n<li>\n<p>Alex also generates new long-term addresses for Blair and Charlie, derived from the addresses in AB and AC, and sends them along with the placeholder identities.</p>\n</li>\n<li>\n<p>All three participants now have the necessary info to send each other bidirectional messages. The combination of cryptographic identity and address (plus additional metadata) form a group proton for each participant.</p>\n</li>\n<li>\n<p>Alex completes the introduction by forming an MLS group with the group protons $$GP_A$$, $$GP_{AB}$$, and $$GP_{AC}$$</p>\n</li>\n</ul>\n<p>The state of this group is &quot;Alex has created a group of 3, including 2 invitees Alex asserts to be Blair and Charlie&quot;</p>\n<p><img src=\"https://messaging-interop.github.io/img/331.png\" alt=\"Diagram of resulting group with placeholder identities\" /></p>\n<p>Figure 3.3.1</p>\n<p>If Blair accepts,</p>\n<ul>\n<li>Blair should immediately generate a new identity key $$GP_B$$.</li>\n<li>Blair should attest to Alex that $$GP_B$$ is equivalent to the existing identity $$P_{B to A}$$.</li>\n<li>In the group, Blair should use  $$GP_{AB}$$ to attest that it will be followed by $$GP_B$$, add $$GP_B$$ to the group, and propose to remove itself. $$GP_B$$  can send the commit message to remove the placeholder</li>\n</ul>\n<p>Charlie can similarly replace its placeholder, resulting in the following state:</p>\n<p><img src=\"https://messaging-interop.github.io/img/332.png\" alt=\"Diagram of groups after new members have joined\" /></p>\n<p>Figure 3.3.2</p>\n<p>Blair and Charlie do not have any new trust that these introduced identities are not aliases for Alex, but they can now independently do so, either by verifying the identities directly, or asserting equivalence to other identities they may exchange.</p>\n<p>Lastly, Blair and Charlie can assert equivalence between their group protons with an new, individual proton, to start a 1:1 relationship:</p>\n<p><img src=\"https://messaging-interop.github.io/img/333.png\" alt=\"Diagram of new 1:1 relationship\" /></p>\n<p>Figure 3.3.3</p>\n<h3 id=\"merging-relationships\" tabindex=\"-1\">Merging Relationships <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/3.3-Groups/#merging-relationships\" aria-hidden=\"true\">#</a></h3>\n<p>Blair and Charlie can build trust in this relationship with additional introductions.</p>\n<p>Suppose that Blair and Charlie also have a mutual acquaintance Dani, who introduces them, producing two relationships with low trust.</p>\n<p><img src=\"https://messaging-interop.github.io/img/334.png\" alt=\"Parallel Relationships\" />\nFigure 3.3.4</p>\n<p>Blair and Charlie can perhaps guess, based on preferred name and contextual clues, that this is the same relationship. But merging has to be consensual - both to preserve consistent message ordering on both sides of the conversation, and to allow people agency over separation of their identities. If Charlie asks to merge the threads, Blair may be unable to - the protons may be actually handled by different relationship managers (e.g. in a work/personal separation) on possibly different devices. Or Blair may simply choose not to.</p>\n<p>Let’s say that Charlie initiates the merge. Charlie should attest that $$P_{C via A}$$ and $$P_{C via D}$$ are equivalent, and both should be followed by a new identity $$P_C$$\nand send the attestation to both  $$P_{B via A}$$ and $$P_{B via D}$$ .</p>\n<ul>\n<li>If Blair has already attested that $$P_{B via A}$$ and $$P_{B via D}$$  are equivalent, e.g. by equivalence to a key in an external directory, then the merge is just a request to be negotiated between Charlie and Blair.\n<ul>\n<li>Charlie says, effectively “You told me  $$P_{B via A}$$ and $$P_{B via D}$$  are the same. I am now telling you $$P_{C via A}$$ and $$P_{C via D}$$  are the same, and I’d like to just use $$P_C$$ to talk to a unified identity for you”</li>\n<li>Blair can consent, and generate a $$P_B$$ that follows  $$P_{B via A}$$ and $$P_{B via D}$$ , or ignore the request and continue with separate threads.</li>\n<li>Charlie’s relationship manager can still collapse the conversations visually for convenience (e.g. by threading), but they remain two logically separate conversations between equivalent identities.</li>\n</ul>\n</li>\n<li>If Blair has not attested to the equivalence of their identities, Charlie should start a group with $$P_C$$, $$P_{B via A}$$, and $$P_{B via D}$$ (effectively, introducing  $$P_{B via A}$$ and $$P_{B via D}$$ )\n<ul>\n<li>Charlie effectively says: My identities ($$P_{C via A}$$ and $$P_{C via D}$$) were representations of the same identity. I’m introducing $$P_{B via A}$$ and $$P_{B via D}$$  and I think you may be the same identity”</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://messaging-interop.github.io/img/335.png\" alt=\"Charlie attempts to merge the two threads\" /></p>\n<p>Figure 3.3.5</p>\n<p>Blair can agree and assert the equivalence of $$P_{B via A}$$ and $$P_{B via D}$$ and symmetrically designate a new follow-on merged identity.</p>\n<p>If Alex had maliciously inserted themselves into the introduced relationship BC via A, that is:</p>\n<p><img src=\"https://messaging-interop.github.io/img/336.png\" alt=\"An attempted merge if one of the aliases is a malicous introducer alias\" /></p>\n<p>Figure 3.3.6</p>\n<p>Then Charlie’s attempt to merge the introduced relationships would result in introducing $$P_{B via D}$$ to $$P_{A\\ middle}$$, as the purported pair of $$P_{CviaA}$$. Assuming that $$P_{BviaA}$$ and $$P_{BviaD}$$ are managed by the same relationship manager, which expects $$P_{BviaA}$$ to be in a relationship with $$P_{CviaA}$$, this immediately flags Alex as a meddler.</p>\n<p>Unless Dani and Alex collude, this is a mechanism for Blair and Charlie to detect that their relationship derived from Alex should not be trusted.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-protocol-overview\">The Messaging Layer Security (MLS) Protocol</a> <a href=\"https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-protocol-overview\">https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-protocol-overview</a> <a href=\"https://messaging-interop.github.io/posts/3.3-Groups/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-04T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/3.2-Conversations/",
      "url": "https://messaging-interop.github.io/posts/3.2-Conversations/",
      "title": "3.2. Conversations",
      "content_html": "<p>The architecture of a <a href=\"https://messaging-interop.github.io/posts/3-Relationships\">Proton Relationship</a> reflects a point in time - the protons contain the data needed to encrypt and decrypt the next message in this conversation.</p>\n<p>Ordering these messages in a transcript produces a conversation, and similarly, the identities themselves have an ordered relationship over time.</p>\n<p>In the simplest case, Alex gets an identity public key and pre-keys for Blair in one of the ways enumerated under <a href=\"https://messaging-interop.github.io/posts/3-Identities\">Identities</a>.  They derive a shared secret using X3DH, and exchange messages using Double Ratchet . The messages sent using keys derived from that first key exchange form a single conversation transcript.</p>\n<p>How do Alex and Blair continue their conversation if either of them loses a device? How can they merge and fork conversations as the need arises? Perhaps they wish to fork a conversation they already have into two. Or, they meet in two different contexts or group conversations (e.g. Twitter accounts and an in-person exchange), but don’t need to have a conversation partitioned by those sources of identity. To do so, we need to introduce relations between cryptographic identities.</p>\n<h3 id=\"attestations\" tabindex=\"-1\">Attestations <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/3.2-Conversations/#attestations\" aria-hidden=\"true\">#</a></h3>\n<p>An attestation is a ciphertext that proves the holders of private keys A and B agreed on a relationship between A and B. This can take the following forms:</p>\n<ul>\n<li>Sequential - B follows A\n<ul>\n<li>Proposal: $$Sign(Sign(A||B, A), B)$$</li>\n</ul>\n</li>\n<li>Parallel - A is equivalent to B\n<ul>\n<li>Proposal: $$Sign(A, B) || Sign(B, A)$$</li>\n</ul>\n</li>\n</ul>\n<p>If A or B are an externally attested identity, they should be encoded with data about the external resource (e.g. a url or certificate chain) that attests to the\nMessages from a key B that follows a key A should be merged chronologically with messages from A. Messages from a key B that is equivalent to key A should not be.</p>\n<p>We should consider trust to be transmitted directionally in a Sequential relationship, and bidirectionally in a Parallel relationship</p>\n<ul>\n<li>If B follows A\n<ul>\n<li>I can trust B with the union of trust in A and B</li>\n<li>I learn nothing new about trust in B</li>\n</ul>\n</li>\n<li>If A is equivalent to B\n<ul>\n<li>I can now trust A and B with the union of trust in A and B</li>\n</ul>\n</li>\n</ul>\n<p>These attestations can be used in the following ways:</p>\n<ul>\n<li>Rolling keys over time</li>\n<li>Linking a new identity to an existing one.\n<ul>\n<li>Alex and Blair met and exchanged keys $$IPK_A$$ and $$IPK_B$$, but Alex wants to prove they also have a Twitter Identity $$IPK_{AT}$$.\n<ul>\n<li>Alex should generate a new $$IPK_{A-Merged}$$ and present attestations that it follows $$IPK_A$$ and $$IPK_{AT}$$</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Forking threads\n<ul>\n<li>If Alex wants to fork a conversation they have with Blair across identities  $$IPK_A$$ and $$IPK_B$$, Alex can generate a new identity key $$IPK_{A'}$$, and send a parallel attestation between $$IPK_A$$ and $$IPK_{A'}$$. From Blair’s point of view, $$IPK_{A'}$$ should be a new thread, inheriting whatever trust they had in $$IPK_A$$</li>\n</ul>\n</li>\n<li>Introductions\n<ul>\n<li>Backups are a form of introduction to a potential future self. See [backup]</li>\n</ul>\n</li>\n<li>Merging threads</li>\n</ul>\n<p>Introductions and Merging are complex topics that require groups to resolve.</p>\n<h3 id=\"conflicts\" tabindex=\"-1\">Conflicts <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/3.2-Conversations/#conflicts\" aria-hidden=\"true\">#</a></h3>\n<p>After issuing an attestation that B follows A, clients should delete the private key for A, and sending chain keys derived from A. (They should keep the receiving keys for some period of time). Future messages should be sent with chain keys derived from B.</p>\n<p>Still, conflicts can arise if clients receive conflicting attestations that B follows A, and C follows A. These can result from software bugs, a device with outdated state (see [Devices]), or compromise of private keys. A device with outdated state can heal its state by reaching consensus with a device with newer state about ordering of keys. E.g. by issuing an attestation that C follows B.</p>\n<p>Otherwise, these conflicts must be resolved by the user. There are two cryptographic identities claiming to be Blair, which one is correct? Examples of how this might arise:</p>\n<ul>\n<li>Alex introduces Blair to a backup identity $$A’$$ that follows $$A$$.  The backup service is compromised and an attacker attempts to impersonate Alex using $$A’$$. There are now two claims to Alex’s identity.\n<ul>\n<li>The presumption could be that a use of a backup identity A’ while A is active is fraudulent and should be assumed to be malicious. But Alex’s device might have been compromised, and is attempting to restart their relationship from a backup.</li>\n<li>Technology can’t resolve this conflict - Blair has to socially resolve this conflict between the two claims to Alex’s identity, for example, by verifying keys in person</li>\n</ul>\n</li>\n<li>An external attestation is a way of resolving this conflict.\n<ul>\n<li>It can also be a source of conflict. Blair has a relationship with Alex, and Alex has asserted and equivalence with the public key for @Alex on twitter at a point in time.</li>\n<li>If Twitter publishes a new public key for \\Alex on Twitter, the association is no longer valid, and we have a conflict\n<ul>\n<li>Alex can heal the conflict by issuing an attestation with the new public key</li>\n<li>The conflict may also arise from an account takeover on the external service rather than a compromise of Alex’s device. This conflict also needs to be resolved socially.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n",
      "date_published": "2022-07-04T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/3.1-Identity/",
      "url": "https://messaging-interop.github.io/posts/3.1-Identity/",
      "title": "3.1. Identity",
      "content_html": "<p>A <a href=\"https://messaging-interop.github.io/posts/3-Relationships\">Proton Relationship</a>  gives us a way to send and receive messages with other cryptographic identities. It provides, for our convenience, the remote party’s preferred representation - a preferred name, maybe pronouns or an image. But how can I know who I’m really talking to?</p>\n<p>With phone numbers, how does Alex know that a phone number is Blair’s? Blair could have told Alex directly or over a (possibly insecure) channel; mutual acquaintances may have introduced them, or Alex was able to look up Blair with an external resource - for example, a directory or website.</p>\n<p>Proton Identities mirror these actions - our trust in them is based on “how did I get this identity key?” and “who can vouch for it?:</p>\n<ul>\n<li>Direct Key Exchange - “I got this key from Blair”\n<ul>\n<li>Users can securely establish a local connection (like Bluetooth Pairing) to exchange information to establish a proton relationship, or verify.</li>\n<li>Users should also exchange a preferred name, pronouns, and avatar for convenience through this channel.</li>\n</ul>\n</li>\n<li>Personal Introduction - “Blair introduced me to Charlie”\n<ul>\n<li>If Alex has a proton relationship with Blair and Charlie, Alex can introduce them by sharing public keys and addresses with each of them. Blair and Charlie cannot rule out the possibility that they are talking to an alias for Alex, or that Alex has interposed themselves in the conversation by substituting their own key - unless they independently verify their newly introduced keys.</li>\n<li>Multiple personal introductions can resolve the trust issue - “Blair and Dani both vouch for Charlie’s cryptographic identity”. The mechanism for vouching is detailed in <a href=\"https://messaging-interop.github.io/posts/3.3-Groups\">Groups and Introductions</a></li>\n</ul>\n</li>\n<li>External Attestation “Twitter says these are the keys for @user on Twitter”\n<ul>\n<li>A service can publish a directory of keys (and pre-keys), within a contextual namespace it controls\n<ul>\n<li>These services exist today for end to end messaging platforms - they publish keys for a phone number N in Signal,  and similarly for N in WhatsApp, N in iMessage, etc.</li>\n<li>An email address can convey some context. If a user registers their academic email address (<a href=\"mailto:Alex@example.edu\">Alex@example.edu</a>) with iMessage, you get a contextual cryptographic identity - <a href=\"http://example.edu/\">Example.edu</a> attests to the association of Alex with this email address (notionally, with the institution), and Apple attests to the binding of some cryptographic keys to the email address.</li>\n</ul>\n</li>\n<li>ACME could cut out the intermediary and directly<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/3.1-Identity/#fn1\" id=\"fnref1\">[1]</a></sup> publish keys for an employee or student.\n<ul>\n<li>Similarly, a social service could publish keys for its users - e.g. users on Twitter</li>\n</ul>\n</li>\n<li>The service could make this directory public, or establish some access control, so we shouldn't presume that external attestations are all publicly reachable.</li>\n</ul>\n</li>\n</ul>\n<p>In practice, identities will roll over time, with cryptographic attestations linking them, so an example identity might be:</p>\n<ul>\n<li>Alex exchanged IPK’s in person with Blair in 2015\n-These IPK’s rolled over time, forming a continuous chain of trust, until</li>\n<li>Blair recovered from a backup in 2016 (to keys <a href=\"https://messaging-interop.github.io/posts/5.1-Backup\">pre-attested</a> by Blair before they lost their phone)</li>\n<li>Blair started to link their IPK’s to the identity Blair on Twitter in 2017.</li>\n<li>In 2018 Blair removed the claim that this key is linked to Twitter\n<ul>\n<li>(e.g. they deleted their account)</li>\n</ul>\n</li>\n<li>Alex verified keys with Blair in 2019</li>\n</ul>\n<p>Alex can delete any of this metadata but also loses a stored record of why they trust this identity.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>In practice, with few exceptions, they will engage the services of a vendor to do so - just as they do with academic email and the contextual identity it confers. <a href=\"https://messaging-interop.github.io/posts/3.1-Identity/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-04T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/3-Relationships/",
      "url": "https://messaging-interop.github.io/posts/3-Relationships/",
      "title": "3. Relationships",
      "content_html": "<p>As hinted at, we make relationships the fundamental unit. I don’t have one identity, I have contextual identities defined by my role in a relationship.</p>\n<p>A <strong>relationship</strong> $$R$$ between Alex and Blair is a pair of data structures $$P_a$$ and $$P_b$$, stored by Alex and Blair respectively, that represent each end (role) of the relationship, and contain the data needed to communicate with the other party. Let’s call $$P_a$$ and $$P_b$$ <strong>Protons</strong>, to reflect the intuition that they are entangled (through message exchange) and reflect shared state.</p>\n<p><em>Protons are a conceptual extension of an idea from Double Ratchet’s ratchet keys, that people exchange and automatically update complementary cryptographic state to encrypt and authenticate asynchronous messages. In addition to cryptographic state, Protons also update their delivery addresses and other identity metadata through message exchange.</em></p>\n<p>$$P_a$$ consists of:</p>\n<ul>\n<li>A human-readable identity for $$P_b$$:\n<ul>\n<li>A string representing a preferred name</li>\n<li>Optionally, pronouns</li>\n<li>Optionally, a profile picture</li>\n</ul>\n</li>\n<li>An Identity Public Key ($$IPK_B$$) for $$P_b$$\n<ul>\n<li>Optionally, an external resource that attests to a binding between $$IPK_B$$ and some external identity (e.g. a scoped username - @B on Twitter)</li>\n</ul>\n</li>\n<li>An Identity private key for Pa corresponding to the $$IPK_A$$ held by $$P_b$$</li>\n<li>Message security state variables\n<ul>\n<li>This would be Double Ratchet chain keys for 1:1 conversations and MLS for group conversations</li>\n</ul>\n</li>\n<li>A list of transport mechanisms (minimum 2), that each contains\n<ul>\n<li>A URL representing the service identity and a means to obtain the service's configuration:\n<ul>\n<li>E.g. <a href=\"http://example.com/.well-known/Proton.json\">example.com/.well-known/Proton.json</a>\n(analogous to an MX record)</li>\n</ul>\n</li>\n<li>A long-term delivery address for $$P_b$$ (this facilitates recovery)\n<ul>\n<li>With a guaranteed valid until date</li>\n</ul>\n</li>\n<li>An ephemeral delivery address for $$P_b$$\n<ul>\n<li>With a (closer) guaranteed valid until date</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>A set of associations with other related protons (relationships)defined by cryptographic attestation - see <a href=\"https://messaging-interop.github.io/posts/3.1-Identity\">Identity</a>.</li>\n</ul>\n<h2 id=\"architecture\" tabindex=\"-1\">Architecture <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/3-Relationships/#architecture\" aria-hidden=\"true\">#</a></h2>\n<p>For Alex and Blair to exchange messages through $$R$$, the key functions required are:</p>\n<ul>\n<li>A relationship manager client running on the user’s device(s) that:\n<ul>\n<li>Exposes user interfaces to manage relationships through their lifetime (create, update, introduce, merge, end)</li>\n<li>Decrypts incoming messages, and encrypts outgoing messages for relationships it manages</li>\n<li>Stores a user’s message history</li>\n<li>Optionally,\n<ul>\n<li>Synchronizes these relationships across multiple devices</li>\n<li>Provides backup and recovery of a user’s relationships</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>A message receiving service that accepts services on behalf of a user and routs them to the user's devices.</li>\n<li>A message sending service that serves as an agent for outgoing messages from devices running a relationship manager.</li>\n</ul>\n<p>Alex and Blair do not have to agree on relationship managers, or message sending and receiving services. Different users's software and services must only <a href=\"https://messaging-interop.github.io/posts/4.1-Interoperability\">interoperate</a> in these ways:</p>\n<ul>\n<li>Message receiving services must accept arbitrary messages from message sending services and deliver them to the addressee</li>\n<li>Relationship managers must be able to encrypt and decrypt messages with other relationship managers and process header information intended for the relationship manager.</li>\n</ul>\n<h3 id=\"optional-components\" tabindex=\"-1\">Optional Components <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/3-Relationships/#optional-components\" aria-hidden=\"true\">#</a></h3>\n<p>These are not required, but extend the functionality of the system to match how people commonly exchange messages:</p>\n<ul>\n<li>Attestation Service\n<ul>\n<li>This asserts authority over identities within a namespace (E.g. users on Twitter, or members of a school), and attests to bindings between those namespace identities, and a cryptographic identity ( an Identity Public Key)\n<ul>\n<li>E.g.: (&quot;This is the IPK for @example on Twitter&quot;)</li>\n</ul>\n</li>\n<li>This should also provide addresses and pre-key bundles to facilitate asynchronously starting conversations with these users.</li>\n<li>The service may use Key Transparency to prove its honest issuance of a consistent key directory.</li>\n</ul>\n</li>\n<li>Client Application\n<ul>\n<li>People may use the relationship architecture to exchange messages of a particular application type. For example - payments, or invitations to a real-time end to end encrypted video call. The Relationship Manager does not need to itself implement the rich functionality such applications provide, but it can provide a secure, authenticated mechanism to exchange those payloads across existing relationships.</li>\n<li>In a commercial relationship, where the remote party has an application of their own, the user can choose to route payloads in that relationship to the corresponding app on their device. E.g. a push notification for a bank that is delivered to my banking app so that I can permit or deny a transaction.</li>\n<li>People may also wish to use a different client application to read and write messages. Operating systems should help protect users from message exfiltration by malicious or compromised client apps.</li>\n</ul>\n</li>\n</ul>\n<p>A relationship manager may have default sending and receiving services, but standardized interfaces would allow users to configure a receiving and sending service of their choice.</p>\n",
      "date_published": "2022-07-03T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/2-Vision/",
      "url": "https://messaging-interop.github.io/posts/2-Vision/",
      "title": "2. A Vision for Modern Interoperable Messaging",
      "content_html": "<p>What does messaging look like if we center them on a conversation atop a relationship?</p>\n<p><strong>Start relationships anywhere:</strong> People meet in many different venues and communities, in-person and online. I should be able to start a conversation in any of those places, including bootstrapping from existing conversations.</p>\n<ul>\n<li><strong>Start relationships in person</strong></li>\n<li><strong>Start relationships by introduction</strong>\nIf Alex has relationships with Blair and Charlie, Alex can introduce Blair and Charlie to each other</li>\n<li><strong>Start relationships from a directory</strong>\nThis may be a public directory or an access controlled one.</li>\n</ul>\n<p><strong>Relationships are consensual:</strong>\tI can revoke a person’s permission to contact me.</p>\n<p><strong>Relationships are portable:</strong> I can change devices and software services, and I can safely and automatically update my relationships with new addresses - becuase identities are not based on addresses.</p>\n<p><strong>Relationships are independent:</strong> My identities in different relationships are not linkable unless I choose to make them so. E.g. in a specific context - social group, work, or school, all those individuals expect to know me by the same identity, and those conversations are expected to be linkable. But the conversations I have with my doctor and my employer don’t need to be linkable.</p>\n<p><strong>Relationships are not dependent on a single app or service</strong></p>\n<p><strong>Conversations are secure and private:</strong> Messages in a conversation are transmitted with end to end encryption. Messages are transmitted with ephemeral identifiers.</p>\n<p><strong>Conversations are multi-modal:</strong> I can send different kinds of messages in the same conversation (e.g. a payment, a long mail, or a short text), and I can use other apps to communicate through this relationship in new and novel ways.</p>\n<p><strong>Relationships don’t require both parties to use the same app or service</strong></p>\n<h3 id=\"how-would-people-use-this-system\" tabindex=\"-1\">How would people use this system? <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/2-Vision/#how-would-people-use-this-system\" aria-hidden=\"true\">#</a></h3>\n<p>Alex meets Blair in a running club. They exchange contact info with a tap of their phones, which lets them start a digital relationship and a conversation that spans texts, email, and real-time calls. Blair can send Alex a payment for post-race coffee within the same conversation.</p>\n<p>Blair knows some other runners, and introduces Alex to Charlie and Dani. Alex and Charlie hit it off, but Alex doesn’t want to continue the relationship with Dani. Alice chooses to block Dani, and Dani can’t try to recontact Alex. If Blair insists on reintroducing Dani to Alex, Alex can choose to ignore introductions from Blair, short of wholly blocking Blair.</p>\n<p>Alex starts school, and now has a new set of relationships with everyone at school via the school directory. Blair is a student too, but the digital conversations don’t automatically reveal if Blair in the school directory is the same Blair from the running club. Alex can ask Blair to join the school and running conversations. Or perhaps they’d like to keep those parts of ourselves separate, and keep parallel conversations.</p>\n<p>Alex builds a close friendship with Emery from school. Emery graduates and is no longer in the school directory, but the relationship remains. They can continue their conversation without a new exchange of addresses, even as the school no longer attests to Emery’s identity as a current student. If Emery was also relying on the school to provide their messaging service (as people often do with email), they can sign up for a new service, and Emery’s client software can automatically and safely update Emery’s relationships with a new address - in a way that is not safe to automatically update my contacts with a new phone number or email address - because the delivery addresses they use are no longer their identity.</p>\n<p>Alex starts a relationship with a merchant in a similar way. This allows the merchant to contact Alex with time-sensitive (order notification, 2FA codes) and slow messages (newsletters). These time-sensitive messages could also be forwarded to the merchant’s app (e.g. an app-delegated login - like Duo or the Blizzard authenticator) instead of being handed as a text message. Alice can also message or call the business from this same authenticated identity, without having to manually authenticate or provide authentication information over an untrusted channel.</p>\n<p>All this happens without any of us having to exchange phone numbers or email addresses, or to update them over time with our relationships.</p>\n",
      "date_published": "2022-07-02T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/1-Messaging-Today/",
      "url": "https://messaging-interop.github.io/posts/1-Messaging-Today/",
      "title": "1. Messaging Today",
      "content_html": "<p>Today, when I talk to people on the internet, I use static digital addresses - phone numbers and email addresses - to do so, even if I’m not actually using PSTN or email.  And when I create accounts in systems, that digital address is usually a recovery factor - or in some cases is the only authentication factor.</p>\n<p>We’ve bootstrapped accounts and messaging system off these addresses because they have these useful properties:</p>\n<ul>\n<li><strong>Human-rememberable strings</strong> - I can remember and give out my own addresses.</li>\n<li><strong>Global, federated namespace</strong> - There are many competing providers of phone and email service. Both email and SMS provide a resolution mechanism where people can message each other without having to understand the other’s choice of service provider.</li>\n<li><strong>Robust Identity Recovery</strong> I can use a phone number or email address to recover an account. I can generally also recover access to my phone number or email address if I destroy my SIM card and forget my passwords, by convincing a  service provider that I am still the same person.</li>\n</ul>\n<p>But they have significant issues:</p>\n<ul>\n<li>These systems share a basic assumption that anyone who has an address, has permission to message that user.\n<ul>\n<li>This is rooted in a lack of prearrangement about the identity I will receive messages from when, e.g., I enter an email address or phone number on a form. Socially, people make that arrangement when exchanging phone numbers.</li>\n<li>So while systems attempt to filter unsolicited messages by an allow-list that doesn’t work for email, and is an incomplete answer as people will continue to receive solicited messages and calls from unknown addresses.</li>\n</ul>\n</li>\n<li>Weakly portable\n<ul>\n<li>Many countries require that phone numbers be portable - this helps enable competition so that people aren’t locked into a particular provider for their identity\n<ul>\n<li>Yet numbers are not portable across countries</li>\n</ul>\n</li>\n<li>Emails are by design not portable. Often they confer some association with the institution. If one can manage holding on to an address, forwarding allows some weak portability.</li>\n<li>When people move internationally, graduate from school, or change their ISP, they often discover how many relationships are based on these addresses, and how much work it is to transition to new addresses.</li>\n</ul>\n</li>\n<li>A single, global identity allows people to be tracked unexpectedly across different contexts\n<ul>\n<li>Virtual email addresses are one approach to mitigating email-based tracking.</li>\n</ul>\n</li>\n</ul>\n<p>With years of experience building and using these systems, we can imagine an <a href=\"https://messaging-interop.github.io/posts/2-Vision\">evolved messaging architecture</a>, that centers on people’s relationships.</p>\n",
      "date_published": "2022-07-01T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/0-Overview/",
      "url": "https://messaging-interop.github.io/posts/0-Overview/",
      "title": "Overview",
      "content_html": "<ol>\n<li><a href=\"https://messaging-interop.github.io/posts/1-Messaging-Today\">Messaging as it exists today</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/2-Vision\">A vision for a future of messaging</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/3-Relationships\">Core Concepts - Relationships</a></li>\n</ol>\n<ul>\n<li><a href=\"https://messaging-interop.github.io/posts/3.1-Identity\">3.1 Identity</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/3.2-Conversations\">3.2 Conversations</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/3.3-Groups\">3.3 Groups and Introductions</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/3.4-Devices\">3.4 Multiple Devices</a></li>\n</ul>\n<ol start=\"4\">\n<li><a href=\"https://messaging-interop.github.io/posts/4-Ideas\">Ideas</a></li>\n</ol>\n<ul>\n<li><a href=\"https://messaging-interop.github.io/posts/4.1-Interoperability\">4.1 Interoperability</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/4.2-Trust\">4.2 Trust</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/4.3-Unsolicited-Messages\">4.3 Unsolicited Messages</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/4.4-Transit-Privacy\">4.4 Message privacy in transit</a></li>\n</ul>\n<ol start=\"5\">\n<li>Other parts of the ecosystem</li>\n</ol>\n<ul>\n<li><a href=\"https://messaging-interop.github.io/posts/5.1-Backup\">5.1 Backup</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/5.2-Self-introductions\">5.2 Self-introductions</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/5.3-Attachments\">5.3 Attachments</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/5.4-Organizations\">5.4 Organizational Identity</a></li>\n</ul>\n<ol start=\"6\">\n<li>Sample Implementations</li>\n</ol>\n<ul>\n<li><a href=\"https://messaging-interop.github.io/posts/6.1-Relationship-Manager\">6.1 Relationship Manager</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/6.2-Receiving-Service\">6.2 Receiving Service</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service\">6.3 Sending Service</a></li>\n</ul>\n<ol start=\"7\">\n<li><a href=\"https://messaging-interop.github.io/posts/7-Related-Work\">Related Work</a></li>\n</ol>\n<p>Today, secure messaging at scale (Signal, WhatsApp, and iMessage) sits in centralized ecosystems, each of them layering different cryptographic identities atop a phone number that a person uses.</p>\n<p>In practice, the fracturing of people’s social relationships among those ecosystems results in the frustrating experience of using multiple messaging apps simultaneously - and worse, fracturing conversations with the same person across multiple apps. There’s been a renewed interest in interoperability, spurred by the EU’s requirement for such in the DMA. <sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/0-Overview/#fn1\" id=\"fnref1\">[1]</a></sup> <sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/0-Overview/#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<p>Rather than simply gluing these systems together, I propose a vision of a modern messaging system that provides:</p>\n<ul>\n<li>Unified identity across modes of conversation\n<ul>\n<li>I should be able to use a single identity to exchange messages or email - my identity shouldn't depend on the app or service I use.</li>\n</ul>\n</li>\n<li>Diversified identity across different conversations\n<ul>\n<li>My ability to separate conversations and role-based identities is not limited to how many phone numbers or email addresses I have.</li>\n</ul>\n</li>\n<li>Interoperability and Portability\n<ul>\n<li>People can communicate without having to agree on an app or service.</li>\n<li>People can change apps and service providers and seamlessly continue a conversation.</li>\n</ul>\n</li>\n<li>Security and Privacy\n<ul>\n<li>Messages are end to end encrypted between identities</li>\n<li>Messages are transmitted with ephemeral addresses</li>\n</ul>\n</li>\n<li>Protection against unsolicited messages</li>\n</ul>\n<h3 id=\"motivation\" tabindex=\"-1\">Motivation <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/0-Overview/#motivation\" aria-hidden=\"true\">#</a></h3>\n<p>I am not my phone number or email address(es). But these digital addresses have become our de facto online identities. And while they have become so for very <a href=\"https://messaging-interop.github.io/posts/1-Messaging-Today\">good reasons</a>, singular delivery addresses make it cumbersome to manage the many different identities we have in our lives - with family, friends, classmates, coworkers, and all the other social circles we inhabit. People go to great lengths and costs to acquire additional phone numbers or email addresses to keep those social circles separate.</p>\n<p>This assumption that users have a single or primary identity is baked into much of our software and services, including cryptographic identity proposals and services.</p>\n<p>Virtual addresses like email aliases are a start to a world where addresses no longer define our identity, but are in service of the many roles we inhabit. But in practice, they also demonstrate the difficulty of managing partitioned identities in an ecosystem that assumes that your address is your identity.</p>\n<p>What if, instead of starting from the notion of a single identity, we think about a pairwise relationship as the fundamental unit? I have a relationship with another person, though which we have a conversation in many different mediums - messaging, email, or real-time audio and video. My contextual identity is the role I inhabit in this relationship. The technologies and addresses of the different mediums are just implementation details - details that I have to manage today manually in a Contacts app.</p>\n<p>I have many such relationships, possibly with the same person. Alex and Blair could be coworkers, and competitors in a game, and may want to keep those conversations separate.</p>\n<p>We can build a new communications architecture that more naturally maps to our relationships.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://educatedguesswork.org/posts/messaging-e2e/\">End-to-End Encryption and Messaging Interoperability</a> <a href=\"https://educatedguesswork.org/posts/messaging-e2e/\">https://educatedguesswork.org/posts/messaging-e2e/</a> <a href=\"https://messaging-interop.github.io/posts/0-Overview/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://matrix.org/blog/2022/03/29/how-do-you-implement-interoperability-in-a-dma-world\">How do you implement interoperability in a DMA world? | Matrix.org</a> <a href=\"https://matrix.org/blog/2022/03/29/how-do-you-implement-interoperability-in-a-dma-world\">https://matrix.org/blog/2022/03/29/how-do-you-implement-interoperability-in-a-dma-world</a> <a href=\"https://messaging-interop.github.io/posts/0-Overview/#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-06-30T00:00:00Z"
    }
  ]
}
