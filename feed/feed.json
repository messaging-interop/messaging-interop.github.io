{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Modern Interoperable Messaging",
  "language": "en",
  "home_page_url": "https://messaging-interop.github.io/",
  "feed_url": "https://example.com/feed/feed.json",
  "description": "Ideas for portable, secure, private messaging",
  "author": {
    "name": "Mark Xue",
    "url": "https://messaging-interop.github.io/about/"
  },
  "items": [{
      "id": "https://messaging-interop.github.io/posts/reorg/",
      "url": "https://messaging-interop.github.io/posts/reorg/",
      "title": "Reorganization",
      "content_html": "<p>Where did everything go?</p>\n<p>I've moved the technical architecture description into a <a href=\"https://messaging-interop.github.io/docs\">book format</a>, while keeping explainers within the blog. To reduce confusion, where technical content is superceded by the documentation, I have removed it from the blog and linked to the relevant section.</p>\n",
      "date_published": "2022-11-14T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/7-Related-Work/",
      "url": "https://messaging-interop.github.io/posts/7-Related-Work/",
      "title": "7. Related Work",
      "content_html": "<p>This sketch draws on a wealth of prior work that has has gotten us where we are today. This architecture draws inspiration from (and uses as a security primitive) ratcheting message security keys from Double Ratchet and MLS.</p>\n<p>Message transmission architecture has inspiration from onion routing, and is adapted for the different nature of store and forward messaging from client-server sessions. Address diversification is structurally similar to onion routing, and I expect rate limiting between receiving and sending services will draw on operational experience from Tor nodes as well as email domain reputation heuristics.</p>\n<p>Indeed, a conceptual ancestor to onion routing is David Chaum’s proposal for anonymous communication using mixnets:\n<a href=\"https://dl.acm.org/doi/pdf/10.1145/358549.358563\">https://dl.acm.org/doi/pdf/10.1145/358549.358563</a></p>\n<p>I’ve also found helpful (if time-shifted) discussion from Trevor Perrin’s Modern Messaging mailing list archives and the many active participants there who have raised ideas and feedback relevant to different aspects of this sketch.\n<a href=\"https://moderncrypto.org/mail-archive/messaging/\">The Messaging Archives</a></p>\n",
      "date_published": "2022-07-07T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/6.3-Sending-Service/",
      "url": "https://messaging-interop.github.io/posts/6.3-Sending-Service/",
      "title": "6.3. Sending Service",
      "content_html": "<p>The main function of a sending service is as an agent of the user to receive encrypted messages from a user’s device and route them to a receiving service.</p>\n<p>To keep the system performant, the Proton protocol should have an established maximum size. Conformant with other secure messaging protocols, larger attachments can be transmitted out of band of the messaging protocol by uploading an encrypted blob to cloud storage and transmitting the symmetric key through the messaging protocol. The sending service is the most natural place to host this blob storage, as an agent of the sender. Sending services can also serve to abstract away a user’s many devices by providing a way to deduplicate responses from many devices (e.g. an ack message from all of a user’s devices).</p>\n<h2 id=\"basic-implementation\" tabindex=\"-1\">Basic Implementation <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#basic-implementation\" aria-hidden=\"true\">#</a></h2>\n<p>A basic service provider disassociates outgoing messages from user accounts by use of <a href=\"https://blog.cloudflare.com/eliminating-captchas-on-iphones-and-macs-using-new-standard/\">private access tokens</a> to rate limit an unauthenticated endpoint.</p>\n<p>The service provider exposes 2 API’s:</p>\n<ul>\n<li>A message send API, where users provide a private access token, a receiving service (by domain), a recipient address, and an encrypted cipher text.</li>\n<li>A blob upload API, which accepts (a different class of) private access token a file upload, and returns a url for the file.</li>\n</ul>\n<h2 id=\"supporting-services\" tabindex=\"-1\">Supporting Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#supporting-services\" aria-hidden=\"true\">#</a></h2>\n<p>A sending service is also a natural place to host supporting functionality.</p>\n<h3 id=\"message-de-duplication\" tabindex=\"-1\">Message De-duplication <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#message-de-duplication\" aria-hidden=\"true\">#</a></h3>\n<p>To help a user's devices appear as a single entity to remote parties, some messages should be coalesced into one. E.g. if relationship managers acknowledge receipt of messages, N ack's will reveal that the recipient has N online devices. For automated messages like these, relationship managers can attach a message de-dupe id (and agree between devices on a consistent method of generating it), so that the sending service implements a policy of only sending one message for a particular de-dupe id.</p>\n<h3 id=\"synchronizing-cross-user-state\" tabindex=\"-1\">Synchronizing Cross-user state <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#synchronizing-cross-user-state\" aria-hidden=\"true\">#</a></h3>\n<p>Decentralized state management across users is a complex problem. This comes from a number of applications, including group membership and state.<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#fn1\" id=\"fnref1\">[1]</a></sup> Sending services, as a agent of user's devices in hosting data for persistent availabilty by other parties, can also host canonical state of this kind. A sending service acting in this way would fulfill the message ordering function of a delivery service in the MLS architecture.</p>\n<p>Because there are no inherent links between a user's identity (or addresses) within a group, and their identity in other conversations, a sending server can safely hold delivery addresses and IPK's for group members, so that it can perform more complex functions of message fan-out, and sending end to end encrypted messages between the sending service and member protons.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>Signal explains the reasons they moved to a centralized, server-maintained group state, and their mitigations to preserve group privacy: <a href=\"https://signal.org/blog/signal-private-group-system/\">https://signal.org/blog/signal-private-group-system/</a> <a href=\"https://messaging-interop.github.io/posts/6.3-Sending-Service/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-07T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/6.2-Receiving-Service/",
      "url": "https://messaging-interop.github.io/posts/6.2-Receiving-Service/",
      "title": "6.2. Receiving Service",
      "content_html": "<p>draft</p>\n",
      "date_published": "2022-07-07T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/6.1-Relationship-Manager/",
      "url": "https://messaging-interop.github.io/posts/6.1-Relationship-Manager/",
      "title": "6.1 Relationship Manager",
      "content_html": "<p>Draft</p>\n",
      "date_published": "2022-07-07T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/5.4-Organizations/",
      "url": "https://messaging-interop.github.io/posts/5.4-Organizations/",
      "title": "5.4. Organizational Identity",
      "content_html": "<p>Protons solve a number of problems or businesses (or any organization) that communicate with individuals, for which a phone number is a poor abstraction for the many entities (and vendors) that comprise an organization.</p>\n<p>My bank has many phone numbers. There are many scammers who call me posing as my bank, or as a social security agency. People are also habituated to providing authenticating information over the phone, a rich target for phishing.</p>\n<p>Organizations today already have a way of establishing a cryptographic identity - through a CA for a domain. Which while imperfect, is a robust claim that a key belongs to Bank of America. And while I might look on the Bank of America website to check that a phone number is actually theirs, attestation and associated identities allow Bank of America to define some set of identities representing different functional teams - their fraud resolution, customer service.</p>\n<p>Businesses, like consumers, are also facing a fracturing of their messaging platforms as competing services offer B2C platforms, indexed on the same phone number. Should a business send an SMS, or a platform's variety of message, or blast the customer on all of them? A proton, as a representation of a single relationship, means that senders need to only worry about the priority and mode of the message - to include a push notification to their own app, not which client App the user is more likely to use.</p>\n<p>The assumption that sending frequency is capped at the rate of a human's activity is mostly relevant to the relationship between senders devices and their sending service. Organizations are not likely to have device-bound identities, and will likely use a vendor which integrates the relationship manager, and sending and receiving services in a hosted platform. From a receiving service's standpoint, this vendor's sending service that is responsible for all of an organization's B2C relationships, still looks like a well-behaved sending service as it will be sending well-addressed and correctly signed messages to distinct recipients.</p>\n<p>Some allowance might need to made for burst activity (push notification updates to sports scores, perhaps), but that can be resolved non-technically with arrangements between receiving and sending services of sufficient volume that such bursts are an issue.</p>\n",
      "date_published": "2022-07-06T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/5.3-Attachments/",
      "url": "https://messaging-interop.github.io/posts/5.3-Attachments/",
      "title": "5.3. Attachments",
      "content_html": "<p>The proton architecture is intended for store and forward messages that contain encoded text, keys, and URI's resulting from a human action. Data that does not fit, like images, should be sent in an attachment flow that only needs to be standardized between relationship managers.</p>\n<p>The RM message format must include a format for attachments that specifies:</p>\n<ul>\n<li>the encryption and integrity key(s)</li>\n<li>URI for the ciphertext\n<ul>\n<li>duration of validity of the URI</li>\n</ul>\n</li>\n</ul>\n<p>Messages that do not fit in a maximum proton message size (e.g. long emails, or many attachments), can be encoded and sent as an attachment.</p>\n<p>Users should generally rely on their receiving and sending services, as the last hop from the device, for hosting and retrieving blob content. Sketches of implementations:</p>\n<h3 id=\"sending-services\" tabindex=\"-1\">Sending Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/5.3-Attachments/#sending-services\" aria-hidden=\"true\">#</a></h3>\n<p>Sending services can provide users with a resource to upload arbitrary ciphertexts and host them for a fixed duration, under some quota policy.</p>\n<h3 id=\"receiving-services\" tabindex=\"-1\">Receiving Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/5.3-Attachments/#receiving-services\" aria-hidden=\"true\">#</a></h3>\n<p>Users should not generally directly fetch resources from arbitrary servers from their device(s). Receiving services can proxy or cache attachments on behalf of the recipient.</p>\n",
      "date_published": "2022-07-06T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/5.2-Self-introductions/",
      "url": "https://messaging-interop.github.io/posts/5.2-Self-introductions/",
      "title": "5.2. Self-Introduction",
      "content_html": "<p>There are circumstances where I want to talk to people I haven’t met yet, or have a means to introduce themselves. E.g. journalists that post a Signal number publicly, or people who publish an email address on their website (often with some obfuscation to defeat web scraping bots).</p>\n<p>Ideally, these self-introductions would be to a scoped identity, so I can identify the source of self-introduction, and have mitigations against abuse like rate limiting. What we want, then, is not to post a static address, but an online, interactive resource, that grants a rate-limited introduction.</p>\n<p>We can do this by delegating an introduction identity to this introduction service in the following way:\nA user generates\n- $$IPK_P$$ as a public identity,\n- a virtual address $$VA$$ marked for incoming self-introduced messages\n- optionally, some message security pre-keys\nAnd gives them to the introduction service. The introduction service generates a delegated introduction IPK and sends it to the user.</p>\n<p>The external agent can respond to rate-limited requests by\n- Signing a requester’s IPK with its delegated introduction IPK\n- Diversifying the virtual address derived from VA\nAnd returning those to the requester along with pre-keys (if available)</p>\n<p>The user can then accept messages on the VA if they come from an IPK signed by DI. The diversified addresses are single use - they shouldn’t accept messages from different IPK’s.</p>\n",
      "date_published": "2022-07-06T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/5.1-Backup/",
      "url": "https://messaging-interop.github.io/posts/5.1-Backup/",
      "title": "5.1. Backup",
      "content_html": "<p>People need to be able to continue their conversations if they lose their devices and the data on them. Today, this happens because identities (phone numbers and email addresses) are recoverable by appeal to the authority of the service provider, and often some form of contacts or implicit contacts (in message history) are escrowed with some service providers.</p>\n<p>So today, services can impersonate you (in practice, be convinced to allow someone to impersonate - for example in a SIM swap attack), and know who you talk to.</p>\n<p>Photon Relationships can be backed up in a variety of ways reflecting different tradeoffs of recovery and security. Most users, who have cryptographic identities stored securely on their devices, should never escrow their device-stored private keys - compromise of private keys would allow an attacker to impersonate the user.</p>\n<p>We have technologies shipping at scale today that preserve end to end security and allow users to recover their secrets from other devices in a sync circle, or from an escrowed store protected by a secret only the user knows. There are also shipping technologies where users can back up their private data using shared secrets so that no one party can recover the user's data.<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/5.1-Backup/#fn1\" id=\"fnref1\">[1]</a></sup> These methods would be safe to store private keys and allow me to recover from loss of a device without disturbing my relationships. I lose my phone, I recover my relationships from my desktop, and life continues.</p>\n<p>There are users who do not have devices, who today authenticate to online services with a user secret, and rely on the honest behavior of their service providers to not impersonate them. These users should also be able to participate in Photon relationships, but their relationship manager must be honest in representing that these user’s identities are escrowed and not device bound.</p>\n<p>We can provide a third recovery mechanism that is robust against losing all my data and forgetting my recovery secret(s), but has safeguards against the escrow party impersonating me - using the notion of introductions.</p>\n<h3 id=\"escrowed-relationship-backup\" tabindex=\"-1\">Escrowed Relationship Backup <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/5.1-Backup/#escrowed-relationship-backup\" aria-hidden=\"true\">#</a></h3>\n<p>Alex has a relationship with Blair that is based on cryptographic secrets stored in their respective protons. To protect against the loss of that data, Alex can introduce Blair to a future Alex $$A’$$, and escrow $$A'$$'s keys with a third party.</p>\n<p>The data Alex needs to escrow are:</p>\n<ul>\n<li>A long-term address for Blair.</li>\n<li>Blair’s IPK for this relationship</li>\n<li>A signing key for $$A’$$</li>\n<li>A preferred name for Blair</li>\n</ul>\n<p>If Alex loses all of their proton data, they can obtain this backup, notify all their relationships of the loss, and use each $$A'$$ to introduce the relationship to a new device resident identity $$A_r$$.</p>\n<p>As with introductions, remote parties should only accept the use of this placeholder key $$A'$$ for introduction to a new identity. The escrow party cannot impersonate the Alex, but can falsely claim to be a future, post-recovery Alex $$A_r$$. This should be easy to repudiate if Alex is still online. Recipients of such a recovery message should immediately consult $$A$$, and until they can verify $$A_r$$, consider the possibility that the escrow party had inserted themselves in the conversation.</p>\n<p>If Alex’s relationship with Blair is based on a publicly attested identity (i.e. a Twitter handle), Alex can instead rely on Twitter for identity recovery, and to publish a new IPK and address(es) for Alex.</p>\n<p>Escrow parties, then, learn about the remote parties that Alex communicates with. They may be able to associate those backed up contacts with outgoing messages to the long-term address, but by design there is nothing to associate those contacts with user’s incoming messages. Receiving services are natural candidates to escrow these contacts. Using two separate receiving services as the system intends, prevents the escrow party from also denying receiving service to prevent repudiation of a misused backup.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>Apple's account recovery contact: <a href=\"https://support.apple.com/guide/security/account-recovery-contact-security-secafa525057/1/web/1\">https://support.apple.com/guide/security/account-recovery-contact-security-secafa525057/1/web/1</a> <a href=\"https://messaging-interop.github.io/posts/5.1-Backup/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-06T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/4.4-Transit-Privacy/",
      "url": "https://messaging-interop.github.io/posts/4.4-Transit-Privacy/",
      "title": "4.4. Message Privacy in Transit",
      "content_html": "<p>Today, messages - even those that are end to end encrypted - are transmitted with sender and recipient identities in the clear. Eavesdroppers, even if they can’t read the contents, can still determine who is talking to whom, at what time.</p>\n<p>The identities serve the following purposes:</p>\n<ul>\n<li>Parties that route messages need to know their destination</li>\n<li>Recipients need to know the originator of a message\n<ul>\n<li>Encryption schemes depend on the originator identity as the index for which keys to decrypt and authenticate an incoming message</li>\n</ul>\n</li>\n<li>Spammers can have actions enforced against their sending identity at each step in the transmission chain.</li>\n</ul>\n<p>The proton architecture improves on this in two key ways:</p>\n<ul>\n<li>Senders do not attach their identity to the message\n<ul>\n<li>The return path, e.g to acknowledge receipt of a message, is independent of the path the message was received on.</li>\n</ul>\n</li>\n<li>In place of the sender-receiver identity pair, adresses now convey the necessary metadata\n<ul>\n<li>for the receiving service to deliver the message to the intended recipient</li>\n<li>for the recipient to resolve which relationship a message is intended for</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"virtual-addresses\" tabindex=\"-1\">Virtual Addresses <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.4-Transit-Privacy/#virtual-addresses\" aria-hidden=\"true\">#</a></h3>\n<p>Receiving services should provide their users with a supply of virtual addresses, and a mechanism for any sender to further diversify an address so that it is resolvable by the receiving service and no one else.</p>\n<p>Users should assign virtual addresses to relationships and share them with their correspondents; they should not be reused across relationships as that may inadvertently link relationships. Because virtual addresses should not be shared between conversations, the RS can observe that messages for the same virtual address are part of the same conversation. To further protect metadata about a user’s conversations, users should use multiple virtual addresses in the same conversation - ideally, a distinct address per message.</p>\n<h3 id=\"address-diversification\" tabindex=\"-1\">Address diversification <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.4-Transit-Privacy/#address-diversification\" aria-hidden=\"true\">#</a></h3>\n<p>This implies that senders and recipients should be able to diversify addresses for a user, producing new addresses that are unlinkable except by the receiving service. We can do so with the following scheme:</p>\n<p>We define address diversification on a space of addresses $$A = {0,1}^n$$ as a triple of probabilistic polynomial-time algorithms $$(Gen, Diversify, Resolve)$$ such that</p>\n<ol>\n<li>The key generation Gen takes as input the security parameter $$1^n$$ and outputs a pair of keys (pk, sk).</li>\n<li>The probabilistic diversification algorithm Diversify takes as input a public key pk and an address $$a$$ from A, and outputs a diversified address $$d$$.</li>\n<li>The deterministic Resolve algorithm takes as input a private key $$sk$$, and a diversified address $$d$$, and outputs an address $$a$$ or a symbol denoting failure.</li>\n</ol>\n<p>Resolve(Diversify($$a$$, $$pk$$), $$sk$$)  should return $$a$$, and it should not be possible for an adversary to determine $$a$$ given Diversify($$a$$) without $$sk$$.</p>\n<p>Diversify should produce indistinguishable outputs, that is, an attacker cannot determine if the output of Diversify was from the same input address, unless they possess the secret key $$sk$$.</p>\n<p>A public key encryption scheme should satisfy these requirements.</p>\n<p>We apply address diversification as follows:</p>\n<h3 id=\"virtual-address-generation\" tabindex=\"-1\">Virtual address generation <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.4-Transit-Privacy/#virtual-address-generation\" aria-hidden=\"true\">#</a></h3>\n<p>The goals of this scheme:</p>\n<ul>\n<li>A receiving service can resolve addresses to a user</li>\n<li>Parties other than the receiving service and the user cannot link addresses to the same user</li>\n<li>Parties other than the user cannot link addresses to the same relationship</li>\n</ul>\n<ol>\n<li>\n<p>A user and their receiving service agree on a root address $$r$$ ( e.g. a UUID), from which we derive additional addresses. This address cannot be invalidated until all derived addresses have expired, so RM clients should periodically generate a new root address so that old ones can be expired.</p>\n</li>\n<li>\n<p>The Receiving Service generates a diversification keypair ($$pk$$, $$sk$$), and publishes the public diversification key. These keys should also be periodically rotated, and identified by a key generation. So in practice, ($$pk_i$$, $$sk_i$$).</p>\n</li>\n<li>\n<p>The user diversifies the root addresses into recipient-diversified addresses $$RDA_j$$ by applying the diversification function with the RS’s public diversification key:</p>\n<p>$$RDA_j = j || Diversify(r, pk_j)$$</p>\n</li>\n</ol>\n<p>The user should assign distinct RDA’s to each of their relationships, so that presented with a ciphertext addressed to an RDA, the user knows which relationship’s keys it should apply to the ciphertext.</p>\n<p>So far, anyone can generate an RDA that resolves to any root address $$p$$, since $$pk$$ is publicly published. We relay on senders using this to diversify addresses to prevent linking by sending services, and we should not rely on the secrecy of a value shared among many users, like the set of all customers of a receiving service.</p>\n<p>We can ensure that only a user can generate addresses for themselves, by requiring that RDA’s be signed by the user using a signing key $$S_k$$ generated for this purpose and registered with the RS:</p>\n<pre><code>$$RDAS_j = j || Sign( j || SRDA_j, S_k )$$\n</code></pre>\n<p>where i is the generation of the Receiving service’s public key.</p>\n<p>The user then sends addresses of the form $$RDAS_j$$  to remote parties</p>\n<p>These remote parties themselves can diversify the RDA_j by applying the RS’s published diversification key:</p>\n<pre><code>$$SDA_j = k ||Diversify(RDAS_j, pk_k)$$\n</code></pre>\n<p>So, a Relationship Manager, when sending a message, should provide the following to it’s sending service (independent of any authentication or private access token required to use the sending service):</p>\n<ul>\n<li>The ciphertext to be decoded by the remote relationship manager</li>\n<li>The receiving service</li>\n<li>A recipient address of the form $$SDA_j$$</li>\n</ul>\n<p>The sending service’s responsibility is to look up the receiving service’s configuration (by analog to email, examine the MX record for the recipient domain), and transmit the ciphertext and recipient address.</p>\n<p>The receiving service, on receipt of a ciphertext $$c$$ for diversified address $$j || da$$:</p>\n<ul>\n<li>Resolves the sender-diversified address to a recipient-diversified address\n<ul>\n<li>$$(j || rda || signature) = Resolve(da, sk_k)$$</li>\n</ul>\n</li>\n<li>Resolves the recipient-diversified address to a root address\n<ul>\n<li>$$r = Resolve(rda, sk_j)$$</li>\n</ul>\n</li>\n<li>Checks if a user corresponds to that root address, and users the signature key(s) for that user to verify the signature on the recipient-diversified address.</li>\n</ul>\n<p>If both resolution steps, and the signature step succeeds, the receiving service can deliver the message to the user corresponding to the root address.</p>\n",
      "date_published": "2022-07-05T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/4.3-Unsolicited-Messages/",
      "url": "https://messaging-interop.github.io/posts/4.3-Unsolicited-Messages/",
      "title": "4.3. Unsolicited Messages",
      "content_html": "<p>The threat model of unsolicited mail changes considerably if only some <a href=\"https://messaging-interop.github.io/posts/5.2-Self-introductions\">defined endpoints</a> are open to arbitrary senders. Rate limiting can be applied at the point of establishing those self-introductions, not at the point of message receipt.</p>\n<p>Outside of those self-introductions, messages in the proton architecture are dropped unless they have a correctly formed address (including a recipient signature on an intermeidate form of the address), and a correct sender signature for the expected sender for that address.</p>\n<p>Today, spammers have an easy task of obtaining or guessing static, low entropy recipient addresses, and their primary challenge is convincing recipient systems to accept bulk messages. They can often do so by aggregating false individual users (phone number and email accounts), that are difficult to distinguish from normal users until they have successfully sent enough unsolicited mail to be flagged by volume, content, or other behavior as a bulk mailer.</p>\n<p>Under the proton architecture, addresses are high-entropy and easily updated. If an attacker is successful in obtaining or guessing an address, they still have to forge a sender signature, at which point they can only pose as the expected sender, not as an arbitrary new identity.</p>\n<p>The key difference is that where as today, spammers are successful until flagged, authentication prevents spammers from successfully sending unsolicited messages, and attempts to learn information by enumerating the address space or using recipients as encryption oracles exhibit behavior that can be identified and blocked.</p>\n<p>Consequently, receiving services, in accepting a message from sending services, should only confirm the correct acceptance of bytes (and any transport layer message integrity), not the validity of any particular address. Failure to resolve the address, in volume, should be considered a reputational hit for that particular sending service.</p>\n<h3 id=\"device-compromise\" tabindex=\"-1\">Device compromise <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.3-Unsolicited-Messages/#device-compromise\" aria-hidden=\"true\">#</a></h3>\n<p>This does raise the incentive to compromise devices to obtain sender signing keys. The attacker's ability is more powerful in that they can impersonate that particular sender, but limits their ability to pose as an alternate identity.</p>\n",
      "date_published": "2022-07-05T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/4.2-Trust/",
      "url": "https://messaging-interop.github.io/posts/4.2-Trust/",
      "title": "4.2. Trust",
      "content_html": "<p>The privacy of my messages - in transit and after receipt - relies on trust in many different parties, including the other party to a relationship.</p>\n<p>The proton architecture guarantees that people are exchanging messages with (and only with) who they expect to be talking to, and that they are transmitted with ephemeral addresses. It makes no promises about what happens after the message is received, how many devices the recipient is running, or even if the recipient is running a hosted service where a server stores their signing keys. We should not exclude people from this architecture who - for a variety of reasons - do not use device-bound identities. They may not have a device, or have sufficient trust in their device security or recovery methods.</p>\n<p>A very useful property of some messaging apps is ephemerality - that messages disappear after some time, and the client app makes it difficult for recipients to exfiltrate them - e.g. by screenshotting. For users to have an assurance of ephemerality, they need stronger assurances about the remote party's software.</p>\n<p>Federated systems are unable to offer this guarantee. Users that desire this property should agree on a particular software client, which implements its own transport security atop the proton relationship. These clients have several technologies available to attest to each other what client software they are running, like video games which do so to raise difficulty of cheating. Operating systems may assist with this attestation, as iOS does<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/4.2-Trust/#fn1\" id=\"fnref1\">[1]</a></sup>.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://developer.apple.com/documentation/devicecheck/establishing_your_app_s_integrity\">Apple Developer Documentation</a> <a href=\"https://developer.apple.com/documentation/devicecheck/establishing_your_app_s_integrity\">https://developer.apple.com/documentation/devicecheck/establishing_your_app_s_integrity</a> <a href=\"https://messaging-interop.github.io/posts/4.2-Trust/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-05T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/4.1-Interoperability/",
      "url": "https://messaging-interop.github.io/posts/4.1-Interoperability/",
      "title": "4.1. Interoperability",
      "content_html": "<p>A key principle of this architecture is that users do not have to agree on a choice of software or services to communicate securely and privately. There are many ideas for hiding message metadata, but implementing novel strategies is difficult if one has to rely on both parties cooperating.</p>\n<p>This architecture is logically separated so that each piece of the architecture can implement novel approaches. These points of separation require interoperability in the following ways</p>\n<h3 id=\"relationship-manager-to-relationship-manager\" tabindex=\"-1\">Relationship Manager to Relationship Manager <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#relationship-manager-to-relationship-manager\" aria-hidden=\"true\">#</a></h3>\n<ul>\n<li>Relationship Managers must agree on a cipher text and plaintext message format and cipher suites for encrypting and decrypting cipher texts.</li>\n<li>They must interoperate on mechanisms for exchanging and verifying public keys directly</li>\n<li>They must interoperate on commands for message exchange and proton state:\n<ul>\n<li>Message received</li>\n<li>Message read (if recipients choose to send it)</li>\n<li>Updates to associated data for the proton:\n<ul>\n<li>e.g. preferred name, receiving services, addresses</li>\n<li>including requests to update addresses about to expire</li>\n</ul>\n</li>\n<li>Group operations</li>\n<li>Introduction to backups</li>\n<li>Merge requests</li>\n<li>Relationship terminated\n<ul>\n<li>(Clients can also silently ignore relationships, or stop sending message receipt ack's, but users may wish to explicitly message this)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"sending-service-to-receiving-service\" tabindex=\"-1\">Sending Service to Receiving Service <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#sending-service-to-receiving-service\" aria-hidden=\"true\">#</a></h3>\n<p>Receiving Services must be able to accept messages up to the agreed upon protocol size for an arbitrary address from Sending Service.</p>\n<h3 id=\"sending-and-receiving-services\" tabindex=\"-1\">Sending and Receiving Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#sending-and-receiving-services\" aria-hidden=\"true\">#</a></h3>\n<p>Sending and receiving services may expose just server API for RM clients. However, services may find it helpful to use client code to execute novel strategies to hide message metadata from themselves, for example with the use of private access tokens.</p>\n<p>We can enable users to use a single relationship manager with different (possibly concurrently) sending and receiving services and simplify the interface as follows:</p>\n<h3 id=\"sending-services\" tabindex=\"-1\">Sending Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#sending-services\" aria-hidden=\"true\">#</a></h3>\n<ul>\n<li>Sending services should provide the Relationship Manager with an API for the RM to send a message for a particular address</li>\n<li>Sending services should also provide the Relationship Manager with an API to upload a ciphertext to cloud storage, and return a URI where it can be retrieved.\n<ul>\n<li>Sending Services should provide the Relationship Manager with an API to learn about the availability (e.g. if offline) and capacity for message sending and attachment upload</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"receiving-services\" tabindex=\"-1\">Receiving Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#receiving-services\" aria-hidden=\"true\">#</a></h3>\n<p>Receiving services have two key functions - address generation, and message receipt.\nThe receiving service should expose API to Relationship Managers for address management:</p>\n<ul>\n<li>generate a long-term address\n<ul>\n<li>optionally, revoke a long-term address</li>\n</ul>\n</li>\n<li>generate an ephemeral, derived address from a long-term address</li>\n</ul>\n<p>Receiving services should offer a mechanism for any party to, given an address A' for that service, derive an ephemeral address that is only linkable to A by the receiving service. Section <a href=\"https://messaging-interop.github.io/posts/4.4-Transit-Privacy\">4.4 Transit Privacy</a> gives a sketch of how to do so with public key cryptography.</p>\n<p>The receiving service should also expose API to Relationship Managers for message delivery:</p>\n<ul>\n<li>\n<p>deliver a message to the Relationship Manager for a given address</p>\n</li>\n<li>\n<p>Allow the Relationship Manager to specify latency for specific long-term addresses (e.g. to manage the pull/push tradeoff centrally within the relationship manager)</p>\n</li>\n<li>\n<p>The RM provides an API for the SS to tell it of changes to the sending configuration (specifically, permitted payload sizes), and available sending options (e.g. a privacy vs latency trade off)</p>\n</li>\n</ul>\n<h2 id=\"portability\" tabindex=\"-1\">Portability <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#portability\" aria-hidden=\"true\">#</a></h2>\n<p>These interfaces allow for easy portability</p>\n<h3 id=\"sending-service\" tabindex=\"-1\">Sending Service <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#sending-service\" aria-hidden=\"true\">#</a></h3>\n<p>Relationship managers may switch arbitrarily among sending services without any cooperation from remote parties. People should maintain at least 2 for redundancy, and relationship managers may freely use any service that the user has configured.</p>\n<h3 id=\"receiving-service\" tabindex=\"-1\">Receiving Service <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#receiving-service\" aria-hidden=\"true\">#</a></h3>\n<p>Because addresses have a finite lifetime, and relationship managers can safely and automatically update them without user intervention, people can safely cutover from one receiving service to another without losing messages. They should already have redundant receiving services configured.</p>\n<p>After a user tells their relationship manger to sunset a particular receiving service R</p>\n<ul>\n<li>The relationship manager should cease issuing addresses from R and cut over to alternate receiving services.\n<ul>\n<li>The user can safely terminate their relationship with R after the last issued address has expired</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"relationship-manager\" tabindex=\"-1\">Relationship Manager <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4.1-Interoperability/#relationship-manager\" aria-hidden=\"true\">#</a></h3>\n<p>Switching relationship managers is more complex. Relationship managers should allow users to export their messages (it's their data), but to preserve the security of a user's communications, relationship managers should not allow the export of private keys. When people choose to switch relationship managers (e.g. from a cross-platform app to the platform's native implementation of a relationship manager, or vice versa), this necessarily has to be an event visible to remote parties as an introduction.</p>\n<p><a href=\"https://messaging-interop.github.io/posts/5.1-Backup.md\">Backed-up relationships and future identities</a> form a useful data structure that can be safely handed off to a successor app, that takes over identities from the previous app.</p>\n",
      "date_published": "2022-07-05T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/4-Ideas/",
      "url": "https://messaging-interop.github.io/posts/4-Ideas/",
      "title": "4. Ideas",
      "content_html": "<p>We've now described enough of the architecture and mechanics to discuss the core goals and ideas.</p>\n<h2 id=\"goals\" tabindex=\"-1\">Goals <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#goals\" aria-hidden=\"true\">#</a></h2>\n<p>The core goal of this architecture is to support the store and forward delivery of discrete messages, end to end encrypted between people as represented by cryptographic identities.</p>\n<p>These messages should have a size limit sufficient to allow for structured objects conveying Unicode encoded text, cryptographic keys, and URI's, but should not be a mechanism to transmit arbitrary packetized data. Each message should correspond to a human action (modulo automated state handling -e.g. an ack- of equal but no greater magnitude) - this forms a natural rate limit.</p>\n<p>The idea is rooted in messaging, but extends to other data that people can exchange like emails, sharing invitations, call invitations, or moves in a turn-based game. It is not a real-time streaming format for audio, video, or movements in a real-time game, which should utilize a streaming transport. However, it can be used to exchange data needed to bootstrap a streaming session between members of a proton relationship.</p>\n<p>There is no guarantee of ordering, nor should clients attempt to fit large payloads in multiple messages - messages that exceed the base size (pictures, long emails, documents) should be handled as <a href=\"https://messaging-interop.github.io/posts/5.3-Attachments\">attachments</a> as they commonly are today.</p>\n<p>Organizations with one to many relationships can fit into this framework, discussed further in <a href=\"https://messaging-interop.github.io/posts/5.3-Organizations\">Organizational Identity</a></p>\n<h2 id=\"deconstructed-messaging\" tabindex=\"-1\">Deconstructed Messaging <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#deconstructed-messaging\" aria-hidden=\"true\">#</a></h2>\n<p>For simplicity, a messaging service combines several different pieces of functionality:</p>\n<ul>\n<li>Authentication - each service manages its own set of identities, tied to an external identity (phone number)</li>\n<li>Message transport</li>\n<li>Client application that stores the user's messages after receipt, and implements a variety of message payloads - standard (images, links) and custom (payments)</li>\n</ul>\n<p>Traditionally, identity has also been bound up with transport. To issue phone numbers, you must be a carrier. The issuer of an email identity are the parties that route the email. This both places a high bar on issuing identities, and binds identity to the service. There's been mixed success in the ecosystem of mail client applications - recent entrants have depended on the integration of client app and the email service.</p>\n<p>For conversations to be portable, they should handle identity independently from transport. For conversations to be interoperable, users need to be able to make independent choices about service providers and client applications.</p>\n<p>So instead of an architecture where members of different ecosystems can message each other, in the way that SMS gateways glued SMS to other messaging systems,<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/4-Ideas/#fn1\" id=\"fnref1\">[1]</a></sup> let's deconstruct the functionality. For Alex and Bob to communicate, they need each of the following pieces:</p>\n<h3 id=\"authentication\" tabindex=\"-1\">Authentication <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#authentication\" aria-hidden=\"true\">#</a></h3>\n<p>Alex and Blair need to exchange identities. We <a href=\"https://messaging-interop.github.io/posts(3.1-Identity)\">previously</a> outlined the ways that people can exchange cryptographic identities like they do phone numbers.</p>\n<h3 id=\"transport\" tabindex=\"-1\">Transport <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#transport\" aria-hidden=\"true\">#</a></h3>\n<p>Alex, from a device, wants to send a message to Blair using that identity. Individual devices are imperfectly online - we want to offload the store and forward to online services that act as online agents for our devices.</p>\n<p>Alex's device, then, should engage a persistently online sending service to offload outgoing messages from their device. That sending service can then attempt &amp; retry delivery to the remote party's online agent for receiving messages.</p>\n<p>These agents have asymmetric roles. Sending services are relatively simple - their role is to take a message from a device and faithfully deliver it to another server endpoint. The <a href=\"https://messaging-interop.github.io/posts/4-Ideas/posts/6.3-Sending-Service\">reference implementation</a> discusses how sending services can authenticate users without authenticating each message. They have related functionality</p>\n<p>Receiving services have a more complex role, since they need to distinguish among incoming messages, which users to route those messages to. Their responsibiity is to keep that knowledge private, by suppring a <a href=\"https://messaging-interop.github.io/posts/4-Ideas/(/posts/4.4-Transit-Privacy)\">virtual address scheme</a> that allows senders to use different addresses for each message.\nThey may engage in strategies to reduce their knowledge about this mapping - a maximalist strategy would be to deliver every message to every user.</p>\n<h2 id=\"reconstructing\" tabindex=\"-1\">Reconstructing <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#reconstructing\" aria-hidden=\"true\">#</a></h2>\n<p>This is a flexible system that allows users to make complex choices - but it is essential to have progressive complexity that doesn't require everyone to make these choices to use the system.</p>\n<p>People's primary or initial interaction with this architecture will be through the relationship manager app, as the way that they start relationships and communicate within them. It serves a set of functions that combine what people typically do within their messaging, contacts, and password manager apps. For simplicity, these apps should come with default receiving, sending, and identity attestation services out of the box, just as messaging apps do today with their backing service.</p>\n<h3 id=\"services\" tabindex=\"-1\">Services <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/4-Ideas/#services\" aria-hidden=\"true\">#</a></h3>\n<p>Sending and receiving services should be cheap to run - they are scaled for human-initiated text and code payloads. Both Apple and Google provide a free receiving service for their mobile OS's in the form of push notification services<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/4-Ideas/#fn2\" id=\"fnref2\">[2]</a></sup> - which end to end encrypted messaging systems today already run on top of for the last leg of delivery to mobile devices. A free tier might include an attachment service sufficient to allow users to send text attachments and images as existing services provide today. Just as with cloud hosting, a variety of economic models might support higher tiers of utilization.</p>\n<p>Key to this assumption is the distinction that sending and receiving services are responsible for message transport (and optionally hosting attachments), not the storage of the resulting plaintext.</p>\n<p>Because the relationship manager is responsible for the security of a person's private keys for their cryptographic identities, and for the backup and recovery of the corresponding relationships, it should also be the default agent for cloud storage and backup of a user's decrypted messages.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>SMS Gateway <a href=\"https://en.wikipedia.org/wiki/SMS_gateway\">https://en.wikipedia.org/wiki/SMS_gateway</a> <a href=\"https://messaging-interop.github.io/posts/4-Ideas/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>APNS (iOS) and Android both have a payload limit of 4KB: <a href=\"https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html\">https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html</a>  <a href=\"https://firebase.google.com/docs/cloud-messaging/concept-options\">https://firebase.google.com/docs/cloud-messaging/concept-options</a>\nAPNS provides a rudimentary form of virtual addressing, in which different developers get different addresses for the same device, to prevent tracking of user activity across apps. <a href=\"https://messaging-interop.github.io/posts/4-Ideas/#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-07-05T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/3.4-Devices/",
      "url": "https://messaging-interop.github.io/posts/3.4-Devices/",
      "title": "3.4. Multiple Devices",
      "content_html": "<p>Edited Nov 14 2022:</p>\n<p>Replaced by the <a href=\"https://messaging-interop.github.io/docs/devices.html\">Devices</a> section of the protocol documentation.</p>\n",
      "date_published": "2022-07-04T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/3.3-Groups/",
      "url": "https://messaging-interop.github.io/posts/3.3-Groups/",
      "title": "3.3. Groups and Introductions",
      "content_html": "<p>Edited Nov 14 2022:</p>\n<p>Replaced by the <a href=\"https://messaging-interop.github.io/docs/groups.html\">Groups</a> section of the protocol documentation.</p>\n",
      "date_published": "2022-07-04T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/3.2-Conversations/",
      "url": "https://messaging-interop.github.io/posts/3.2-Conversations/",
      "title": "3.2. Conversations",
      "content_html": "<p>Edited Nov 14 2022:</p>\n<p>Replaced by the <a href=\"https://messaging-interop.github.io/docs/identities.html\">Identities</a> section of the protocol documentation.</p>\n",
      "date_published": "2022-07-04T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/3.1-Identity/",
      "url": "https://messaging-interop.github.io/posts/3.1-Identity/",
      "title": "3.1. Identity",
      "content_html": "<p>Edited Nov 14 2022:</p>\n<p>Replaced by the <a href=\"https://messaging-interop.github.io/docs/architecture-overview.html\">Architecture &amp; Protocol Model</a> section of the protocol documentation.</p>\n",
      "date_published": "2022-07-04T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/3-Relationships/",
      "url": "https://messaging-interop.github.io/posts/3-Relationships/",
      "title": "3. Relationships",
      "content_html": "<p>Edited Nov 14 2022:</p>\n<p>Replaced by the <a href=\"https://messaging-interop.github.io/docs/introductions.html\">Relationships</a> section of the protocol documentation.</p>\n",
      "date_published": "2022-07-03T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/2-Vision/",
      "url": "https://messaging-interop.github.io/posts/2-Vision/",
      "title": "2. A Vision for Modern Interoperable Messaging",
      "content_html": "<p>What does messaging look like if we center them on a conversation atop a relationship?</p>\n<p><strong>Start relationships anywhere:</strong> People meet in many different venues and communities, in-person and online. I should be able to start a conversation in any of those places, including bootstrapping from existing conversations.</p>\n<ul>\n<li><strong>Start relationships in person</strong></li>\n<li><strong>Start relationships by introduction</strong>\nIf Alex has relationships with Blair and Charlie, Alex can introduce Blair and Charlie to each other</li>\n<li><strong>Start relationships from a directory</strong>\nThis may be a public directory or an access controlled one.</li>\n</ul>\n<p><strong>Relationships are consensual:</strong>\tI can revoke a person’s permission to contact me.</p>\n<p><strong>Relationships are portable:</strong> I can change devices and software services, and I can safely and automatically update my relationships with new addresses - becuase identities are not based on addresses.</p>\n<p><strong>Relationships are independent:</strong> My identities in different relationships are not linkable unless I choose to make them so. E.g. in a specific context - social group, work, or school, all those individuals expect to know me by the same identity, and those conversations are expected to be linkable. But the conversations I have with my doctor and my employer don’t need to be linkable.</p>\n<p><strong>Relationships are not dependent on a single app or service</strong></p>\n<p><strong>Conversations are secure and private:</strong> Messages in a conversation are transmitted with end to end encryption. Messages are transmitted with ephemeral identifiers.</p>\n<p><strong>Conversations are multi-modal:</strong> I can send different kinds of messages in the same conversation (e.g. a payment, a long mail, or a short text), and I can use other apps to communicate through this relationship in new and novel ways.</p>\n<p><strong>Relationships don’t require both parties to use the same app or service</strong></p>\n<h3 id=\"how-would-people-use-this-system\" tabindex=\"-1\">How would people use this system? <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/2-Vision/#how-would-people-use-this-system\" aria-hidden=\"true\">#</a></h3>\n<p>Alex meets Blair in a running club. They exchange contact info with a tap of their phones, which lets them start a digital relationship and a conversation that spans texts, email, and real-time calls. Blair can send Alex a payment for post-race coffee within the same conversation.</p>\n<p>Blair knows some other runners, and introduces Alex to Charlie and Dani. Alex and Charlie hit it off, but Alex doesn’t want to continue the relationship with Dani. Alice chooses to block Dani, and Dani can’t try to recontact Alex. If Blair insists on reintroducing Dani to Alex, Alex can choose to ignore introductions from Blair, short of wholly blocking Blair.</p>\n<p>Alex starts school, and now has a new set of relationships with everyone at school via the school directory. Blair is a student too, but the digital conversations don’t automatically reveal if Blair in the school directory is the same Blair from the running club. Alex can ask Blair to join the school and running conversations. Or perhaps they’d like to keep those parts of ourselves separate, and keep parallel conversations.</p>\n<p>Alex builds a close friendship with Emery from school. Emery graduates and is no longer in the school directory, but the relationship remains. They can continue their conversation without a new exchange of addresses, even as the school no longer attests to Emery’s identity as a current student. If Emery was also relying on the school to provide their messaging service (as people often do with email), they can sign up for a new service, and Emery’s client software can automatically and safely update Emery’s relationships with a new address - in a way that is not safe to automatically update my contacts with a new phone number or email address - because the delivery addresses they use are no longer their identity.</p>\n<p>Alex starts a relationship with a merchant in a similar way. This allows the merchant to contact Alex with time-sensitive (order notification, 2FA codes) and slow messages (newsletters). These time-sensitive messages could also be forwarded to the merchant’s app (e.g. an app-delegated login - like Duo or the Blizzard authenticator) instead of being handed as a text message. Alice can also message or call the business from this same authenticated identity, without having to manually authenticate or provide authentication information over an untrusted channel.</p>\n<p>All this happens without any of us having to exchange phone numbers or email addresses, or to update them over time with our relationships.</p>\n",
      "date_published": "2022-07-02T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/1-Messaging-Today/",
      "url": "https://messaging-interop.github.io/posts/1-Messaging-Today/",
      "title": "1. Messaging Today",
      "content_html": "<p>Today, when I talk to people on the internet, I use static digital addresses - phone numbers and email addresses - to do so, even if I’m not actually using PSTN or email.  And when I create accounts in systems, that digital address is usually a recovery factor - or in some cases is the only authentication factor.</p>\n<p>We’ve bootstrapped accounts and messaging system off these addresses because they have these useful properties:</p>\n<ul>\n<li><strong>Human-rememberable strings</strong> - I can remember and give out my own addresses.</li>\n<li><strong>Global, federated namespace</strong> - There are many competing providers of phone and email service. Both email and SMS provide a resolution mechanism where people can message each other without having to understand the other’s choice of service provider.</li>\n<li><strong>Robust Identity Recovery</strong> I can use a phone number or email address to recover an account. I can generally also recover access to my phone number or email address if I destroy my SIM card and forget my passwords, by convincing a  service provider that I am still the same person.</li>\n</ul>\n<p>But they have significant issues:</p>\n<ul>\n<li>These systems share a basic assumption that anyone who has an address, has permission to message that user.\n<ul>\n<li>This is rooted in a lack of prearrangement about the identity I will receive messages from when, e.g., I enter an email address or phone number on a form. Socially, people make that arrangement when exchanging phone numbers.</li>\n<li>So while systems attempt to filter unsolicited messages by an allow-list that doesn’t work for email, and is an incomplete answer as people will continue to receive solicited messages and calls from unknown addresses.</li>\n</ul>\n</li>\n<li>Weakly portable\n<ul>\n<li>Many countries require that phone numbers be portable - this helps enable competition so that people aren’t locked into a particular provider for their identity\n<ul>\n<li>Yet numbers are not portable across countries</li>\n</ul>\n</li>\n<li>Emails are by design not portable. Often they confer some association with the institution. If one can manage holding on to an address, forwarding allows some weak portability.</li>\n<li>When people move internationally, graduate from school, or change their ISP, they often discover how many relationships are based on these addresses, and how much work it is to transition to new addresses.</li>\n</ul>\n</li>\n<li>A single, global identity allows people to be tracked unexpectedly across different contexts\n<ul>\n<li>Virtual email addresses are one approach to mitigating email-based tracking.</li>\n</ul>\n</li>\n</ul>\n<p>With years of experience building and using these systems, we can imagine an <a href=\"https://messaging-interop.github.io/posts/2-Vision\">evolved messaging architecture</a>, that centers on people’s relationships.</p>\n",
      "date_published": "2022-07-01T00:00:00Z"
    },{
      "id": "https://messaging-interop.github.io/posts/0-Overview/",
      "url": "https://messaging-interop.github.io/posts/0-Overview/",
      "title": "Overview",
      "content_html": "<ol>\n<li><a href=\"https://messaging-interop.github.io/posts/1-Messaging-Today\">Messaging as it exists today</a></li>\n<li><a href=\"https://messaging-interop.github.io/posts/2-Vision\">A vision for a future of messaging</a></li>\n</ol>\n<p><a href=\"https://messaging-interop.github.io/docs\">Documentation</a></p>\n<p>Today, secure messaging at scale (Signal, WhatsApp, and iMessage) sits in centralized ecosystems, each of them layering different cryptographic identities atop a phone number that a person uses.</p>\n<p>In practice, the fracturing of people’s social relationships among those ecosystems results in the frustrating experience of using multiple messaging apps simultaneously - and worse, fracturing conversations with the same person across multiple apps. There’s been a renewed interest in interoperability, spurred by the EU’s requirement for such in the DMA. <sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/0-Overview/#fn1\" id=\"fnref1\">[1]</a></sup> <sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/0-Overview/#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<p>Rather than simply gluing these systems together, I propose a vision of a modern messaging system that provides:</p>\n<ul>\n<li>Unified identity across modes of conversation\n<ul>\n<li>I should be able to use a single identity to exchange messages or email - my identity shouldn't depend on the app or service I use.</li>\n</ul>\n</li>\n<li>Diversified identity across different conversations\n<ul>\n<li>My ability to separate conversations and role-based identities is not limited to how many phone numbers or email addresses I have.</li>\n</ul>\n</li>\n<li>Interoperability and Portability\n<ul>\n<li>People can communicate without having to agree on an app or service.</li>\n<li>People can change apps and service providers and seamlessly continue a conversation.</li>\n</ul>\n</li>\n<li>Security and Privacy\n<ul>\n<li>Messages are end to end encrypted between identities</li>\n<li>Messages are transmitted with ephemeral addresses</li>\n</ul>\n</li>\n<li>Protection against unsolicited messages</li>\n</ul>\n<h2 id=\"motivation\" tabindex=\"-1\">Motivation <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/0-Overview/#motivation\" aria-hidden=\"true\">#</a></h2>\n<p>Interoperability between different E2E messaging apps - that is, a user in WhatsApp messaging a user in Signal as the DMA envisions it - will degrade the security and user experience that people have today in messaging apps<sup class=\"footnote-ref\"><a href=\"https://messaging-interop.github.io/posts/0-Overview/#fn3\" id=\"fnref3\">[3]</a></sup>. What exists today are secure, expressive, silos of E2E messaging, sitting atop the identities from insecure but interoperable transports of SMS and email.</p>\n<p>To attempt to flatten this layering, as the DMA does, risks losing much of what makes modern messaging secure and expressive. What I propose here is an approach to bringing modern concepts of E2E security, cryptographic identities, portability, and permission to contact to an underlying, federated messaging layer that accomodates the broadest diversity of human relationships. Atop which people can still coordinate to use a particular app or medium to communicate in ways that differentiate themselves from the base layer in unique ways like security or expressiveness.</p>\n<h3 id=\"identity\" tabindex=\"-1\">Identity <a class=\"direct-link\" href=\"https://messaging-interop.github.io/posts/0-Overview/#identity\" aria-hidden=\"true\">#</a></h3>\n<p>I am not my phone number or email address(es). But these digital addresses have become our de facto online identities. And while they have become so for very <a href=\"https://messaging-interop.github.io/posts/1-Messaging-Today\">good reasons</a>, singular delivery addresses make it cumbersome to manage the many different identities we have in our lives - with family, friends, classmates, coworkers, and all the other social circles we inhabit. People go to great lengths and costs to acquire additional phone numbers or email addresses to keep those social circles separate.</p>\n<p>This assumption that users have a single or primary identity is baked into much of our software and services, including cryptographic identity proposals and services.</p>\n<p>Virtual addresses like email aliases are a start to a world where addresses no longer define our identity, but are in service of the many roles we inhabit. But in practice, they also demonstrate the difficulty of managing partitioned identities in an ecosystem that assumes that your address is your identity.</p>\n<p>What if, instead of starting from the notion of a single identity, we think about a pairwise relationship as the fundamental unit? I have a relationship with another person, though which we have a conversation in many different mediums - messaging, email, or real-time audio and video. My contextual identity is the role I inhabit in this relationship. The technologies and addresses of the different mediums are just implementation details - details that I have to manage today manually in a Contacts app.</p>\n<p>I have many such relationships, possibly with the same person. Alex and Blair could be coworkers, and competitors in a game, and may want to keep those conversations separate.</p>\n<p>We can build a new communications architecture that more naturally maps to our relationships.</p>\n<hr class=\"footnotes-sep\" />\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p><a href=\"https://educatedguesswork.org/posts/messaging-e2e/\">End-to-End Encryption and Messaging Interoperability</a> <a href=\"https://educatedguesswork.org/posts/messaging-e2e/\">https://educatedguesswork.org/posts/messaging-e2e/</a> <a href=\"https://messaging-interop.github.io/posts/0-Overview/#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p><a href=\"https://matrix.org/blog/2022/03/29/how-do-you-implement-interoperability-in-a-dma-world\">How do you implement interoperability in a DMA world? | Matrix.org</a> <a href=\"https://matrix.org/blog/2022/03/29/how-do-you-implement-interoperability-in-a-dma-world\">https://matrix.org/blog/2022/03/29/how-do-you-implement-interoperability-in-a-dma-world</a> <a href=\"https://messaging-interop.github.io/posts/0-Overview/#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn3\" class=\"footnote-item\"><p>Alec Muffet makes the case clearly here: <a href=\"https://alecmuffett.com/alecm/e2e-primer/e2e-primer-web.html#interoperability\">https://alecmuffett.com/alecm/e2e-primer/e2e-primer-web.html#interoperability</a> <a href=\"https://messaging-interop.github.io/posts/0-Overview/#fnref3\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n",
      "date_published": "2022-06-30T00:00:00Z"
    }
  ]
}
